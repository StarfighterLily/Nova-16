; FORTH Program - Generated by forth_compiler.py
; Nova-16 Assembly Language

ORG 0x1000

; Initialize stacks
MOV P8, 0xF000    ; Parameter stack pointer
MOV P9, 0xFFFF    ; Return stack pointer

; Main program entry point
main:
    CALL forth_main
    HLT

; FORTH main routine
; Variable: P0
    ; Variable storage (2 bytes)


; Variable: P1
    ; Variable storage (2 bytes)


; Variable: R0
    ; Variable storage (2 bytes)


; Word: GFXTEST
GFXTEST:
    MOV R0, 1
    DEC P8
    DEC P8
    MOV [P8], R0
    ; VMODE - Set video mode
    ; Stack before: ( mode -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    MOV VM, R0
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    CALL VX
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    CALL VY
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    ; Variable access: P0
    MOV P0, 8192
    DEC P8
    DEC P8
    MOV [P8], P0
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV P0, 1000
    DEC P8
    DEC P8
    MOV [P8], P0
    ; Variable access: P1
    MOV P0, 8194
    DEC P8
    DEC P8
    MOV [P8], P0
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    ; Variable access: R0
    MOV P0, 8196
    DEC P8
    DEC P8
    MOV [P8], P0
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV R0, 1
    DEC P8
    DEC P8
    MOV [P8], R0
    ; LAYER - Set active graphics layer
    ; Stack before: ( layer -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    MOV VL, R0
BEGIN1:
    ; Variable access: P0
    MOV P0, 8192
    DEC P8
    DEC P8
    MOV [P8], P0
    ; @
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R0, [R0]
    DEC P8
    DEC P8
    MOV [P8], R0
    ; DUP
    MOV R0, P8
    CMP R0, 0xF000
    JGE stack_underflow
    MOV R0, [P8]
    DEC P8
    DEC P8
    MOV [P8], R0
    MOV P0, 256
    DEC P8
    DEC P8
    MOV [P8], P0
    ; /
    MOV P0, [P8]
    INC P8
    INC P8
    MOV P1, [P8]
    INC P8
    INC P8
    DIV P1, P0
    DEC P8
    DEC P8
    MOV [P8], P1
    CALL VX
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV R0, 255
    DEC P8
    DEC P8
    MOV [P8], R0
    CALL AND
    CALL VY
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    ; Variable access: R0
    MOV P0, 8196
    DEC P8
    DEC P8
    MOV [P8], P0
    ; @
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R0, [R0]
    DEC P8
    DEC P8
    MOV [P8], R0
    CALL SWRITE
    ; Variable access: P0
    MOV P0, 8192
    DEC P8
    DEC P8
    MOV [P8], P0
    ; @
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R0, [R0]
    DEC P8
    DEC P8
    MOV [P8], R0
    MOV R0, 1
    DEC P8
    DEC P8
    MOV [P8], R0
    ; +
    MOV R0, P8
    ADD R0, 4
    CMP R0, 0xF000
    JGE stack_underflow
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    ADD R0, R1
    DEC P8
    DEC P8
    MOV [P8], R0
    ; Variable access: P0
    MOV P0, 8192
    DEC P8
    DEC P8
    MOV [P8], P0
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    ; Variable access: R0
    MOV P0, 8196
    DEC P8
    DEC P8
    MOV [P8], P0
    ; @
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R0, [R0]
    DEC P8
    DEC P8
    MOV [P8], R0
    MOV R0, 1
    DEC P8
    DEC P8
    MOV [P8], R0
    ; +
    MOV R0, P8
    ADD R0, 4
    CMP R0, 0xF000
    JGE stack_underflow
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    ADD R0, R1
    DEC P8
    DEC P8
    MOV [P8], R0
    MOV R0, 255
    DEC P8
    DEC P8
    MOV [P8], R0
    CALL AND
    ; Variable access: R0
    MOV P0, 8196
    DEC P8
    DEC P8
    MOV [P8], P0
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    ; Variable access: P0
    MOV P0, 8192
    DEC P8
    DEC P8
    MOV [P8], P0
    ; @
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R0, [R0]
    DEC P8
    DEC P8
    MOV [P8], R0
    ; Variable access: P1
    MOV P0, 8194
    DEC P8
    DEC P8
    MOV [P8], P0
    ; @
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R0, [R0]
    DEC P8
    DEC P8
    MOV [P8], R0
    CALL =
    ; UNTIL
    MOV R0, [P8]
    INC P8
    INC P8
    CMP R0, 0
    JZ BEGIN1
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    ; VMODE - Set video mode
    ; Stack before: ( mode -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    MOV VM, R0
    MOV R0, 108
    DEC P8
    DEC P8
    MOV [P8], R0
    CALL VX
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV R0, 118
    DEC P8
    DEC P8
    MOV [P8], R0
    CALL VY
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV R0, 95
    DEC P8
    DEC P8
    MOV [P8], R0
    ; Variable access: R0
    MOV P0, 8196
    DEC P8
    DEC P8
    MOV [P8], P0
    ; !
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    MOV [R0], R1
    MOV R0, 5
    DEC P8
    DEC P8
    MOV [P8], R0
    ; LAYER - Set active graphics layer
    ; Stack before: ( layer -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    MOV VL, R0
DB 15
DB " De Nova Stella"
DB 0
    ; Print string literal
    MOV R0, str2
    CALL print_string
    MOV R0, 1
    DEC P8
    DEC P8
    MOV [P8], R0
    ; LAYER - Set active graphics layer
    ; Stack before: ( layer -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    MOV VL, R0
DB 24
DB " FORTH GFX Test Complete"
DB 0
    ; Print string literal
    MOV R0, str3
    CALL print_string
    RET

forth_main:
    ; Initialize FORTH system
    ; Main program
    CALL GFXTEST
    RET

; Print number routine (decimal output)
    ; Convert 16-bit number in R0 to decimal and print
    ; Handle negative numbers
    MOV R1, R0
    MOV R2, 0
    JGE R1, positive
    MOV R2, 1
    NEG R1
positive:
    ; Convert to decimal digits
    MOV P3, 10000
    MOV R4, 0
convert_loop:
    MOV R5, R1
    DIV R5, P3
    ; R5 now contains the digit
    CMP R5, 0
    JZ skip_digit
    MOV R4, 1
    ADD R5, 48
    ; EMIT R5
skip_digit:
    ; Multiply remainder by current place and subtract
    MUL R5, P3
    SUB R1, R5
    ; Next place value
    MOV R5, P3
    DIV R5, 10
    MOV P3, R5
    CMP P3, 0
    JNZ convert_loop
    ; Handle case where number was 0
    CMP R4, 0
    JNZ done_print
    ; MOV R5, 48
    ; EMIT R5
done_print:
    ; Print negative sign if needed
    CMP R2, 0
    JZ no_sign
    ; MOV R5, 45
    ; EMIT R5
no_sign:
    RET

; Print string routine
print_string:
    ; Print string pointed to by R0
    ; String format: length byte, string data, null terminator
    MOV R1, [R0]
    INC R0
print_string_loop:
    CMP R1, 0
    JZ print_string_done
    MOV R2, [R0]
    ; EMIT R2
    INC R0
    DEC R1
    JMP print_string_loop
print_string_done:
    RET

; Error handling routines
stack_underflow:
    ; Handle stack underflow error
    ; For now, just halt (could be extended to print error message)
    HLT

    ; Handle stack overflow error
    ; For now, just halt (could be extended to print error message)
    HLT

; CR routine - print carriage return
    ; Print newline (simplified - just return)
    RET
