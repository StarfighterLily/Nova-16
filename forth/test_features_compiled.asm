; FORTH Program - Generated by forth_compiler.py
; Nova-16 Assembly Language

ORG 0x1000

; Initialize stacks
MOV P8, 0xF000    ; Parameter stack pointer
MOV P9, 0xFFFF    ; Return stack pointer

; Main program entry point
main:
    CALL forth_main
    HLT

; FORTH main routine
forth_main:
    ; Initialize FORTH system
    ; Main program code will be inserted here
    RET

; Print number routine (decimal output)
print_number:
    ; Convert 16-bit number in R0 to decimal and print
    ; Handle negative numbers
    MOV R1, R0
    MOV R2, 0
    JGE R1, positive
    MOV R2, 1
    NEG R1
positive:
    ; Convert to decimal digits
    MOV P3, 10000
    MOV R4, 0
convert_loop:
    MOV R5, R1
    DIV R5, P3
    ; R5 now contains the digit
    CMP R5, 0
    JZ skip_digit
    MOV R4, 1
    ADD R5, 48
    ; EMIT R5
skip_digit:
    ; Multiply remainder by current place and subtract
    MUL R5, P3
    SUB R1, R5
    ; Next place value
    MOV R5, P3
    DIV R5, 10
    MOV P3, R5
    CMP P3, 0
    JNZ convert_loop
    ; Handle case where number was 0
    CMP R4, 0
    JNZ done_print
    ; MOV R5, 48
    ; EMIT R5
done_print:
    ; Print negative sign if needed
    CMP R2, 0
    JZ no_sign
    ; MOV R5, 45
    ; EMIT R5
no_sign:
    RET

; Print string routine
print_string:
    ; Print string pointed to by R0
    ; String format: length byte, string data, null terminator
    MOV R1, [R0]
    INC R0
print_string_loop:
    CMP R1, 0
    JZ print_string_done
    MOV R2, [R0]
    ; EMIT R2
    INC R0
    DEC R1
    JMP print_string_loop
print_string_done:
    RET

; Error handling routines
    ; Handle stack underflow error
    ; For now, just halt (could be extended to print error message)
    HLT

    ; Handle stack overflow error
    ; For now, just halt (could be extended to print error message)
    HLT

; CR routine - print carriage return
    ; Print newline (simplified - just return)
    RET

; Word: TEST_CONTROL
    MOV R0, 10
    DEC P8
    DEC P8
    MOV [P8], R0
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    ; DO (limit index DO)
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    ; Push to return stack for loop control
    DEC P9
    DEC P9
    MOV [P9], R1
    DEC P9
    DEC P9
    MOV [P9], R0
    ; I - Get loop index
    MOV R0, [P9]
    DEC P8
    DEC P8
    MOV [P8], R0
    ; DUP
    MOV R0, [P8]
    DEC P8
    DEC P8
    MOV [P8], R0
    ; .
    MOV R0, [P8]
    INC P8
    INC P8
    CALL print_number
    ; I - Get loop index
    MOV R0, [P9]
    DEC P8
    DEC P8
    MOV [P8], R0
    MOV R0, 2
    DEC P8
    DEC P8
    MOV [P8], R0
    ; =
    MOV R0, [P8]
    INC P8
    INC P8
    MOV R1, [P8]
    INC P8
    INC P8
    CMP R0, R1
    JZ eq_true3
    MOV R0, 0
    JMP eq_end4
eq_true3:
    MOV R0, -1
eq_end4:
    DEC P8
    DEC P8
    MOV [P8], R0
    ; IF
    MOV R0, [P8]
    INC P8
    INC P8
    CMP R0, 0
    JZ else5
    ; Print string: " Found 2!"
    ; Create string at runtime address
    MOV P0, 12288
    MOV R0, 9
    MOV [P0], R0
    INC P0
    MOV R0, 32
    MOV [P0], R0
    INC P0
    MOV R0, 70
    MOV [P0], R0
    INC P0
    MOV R0, 111
    MOV [P0], R0
    INC P0
    MOV R0, 117
    MOV [P0], R0
    INC P0
    MOV R0, 110
    MOV [P0], R0
    INC P0
    MOV R0, 100
    MOV [P0], R0
    INC P0
    MOV R0, 32
    MOV [P0], R0
    INC P0
    MOV R0, 50
    MOV [P0], R0
    INC P0
    MOV R0, 33
    MOV [P0], R0
    INC P0
    MOV R0, 0
    MOV [P0], R0
    MOV R0, 12288
    CALL print_string
else5:
    ; LOOP
    MOV R0, [P9]
    INC R0
    MOV [P9], R0
    MOV R1, [P9+2]
    CMP R0, R1
    JL do1
    ; Clean up return stack
    INC P9
    INC P9
    INC P9
    INC P9
    RET

; Word: TEST_GRAPHICS
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    ; VMODE - Set video mode
    ; Stack before: ( mode -- )
    MOV R0, [P8]
    INC P8
    INC P8
    MOV VM, R0
    MOV R0, 1
    DEC P8
    DEC P8
    MOV [P8], R0
    ; LAYER - Set active graphics layer
    ; Stack before: ( layer -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    MOV VL, R0
    MOV R0, 100
    DEC P8
    DEC P8
    MOV [P8], R0
    MOV R0, 50
    DEC P8
    DEC P8
    MOV [P8], R0
    MOV R0, 15
    DEC P8
    DEC P8
    MOV [P8], R0
    ; PIXEL - Draw at (x,y) with color
    ; Stack before: ( x y color -- )
    MOV P2, [P8]
    INC P8
    INC P8
    MOV R0, :P2
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R1, :P0
    MOV P1, [P8]
    INC P8
    INC P8
    ; Set coordinates to video registers
    MOV VX, :P1
    MOV VY, R1
    ; Write the pixel
    SWRITE R0
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    ; VX! - Store to VX register
    ; Stack before: ( value -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    MOV VX, R0
    MOV R0, 0
    DEC P8
    DEC P8
    MOV [P8], R0
    ; VY! - Store to VY register
    ; Stack before: ( value -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    MOV VY, R0
    MOV R0, 14
    DEC P8
    DEC P8
    MOV [P8], R0
    ; SWRITE - Write pixel at current coordinates
    ; Stack before: ( color -- )
    MOV P0, [P8]
    INC P8
    INC P8
    MOV R0, :P0
    SWRITE R0
    RET
