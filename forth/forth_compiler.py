#!/usr/bin/env python3
"""
FORTH Compiler for Nova-16
Compiles FORTH source code to Nova-16 assembly language.

This compiler translates FORTH programs into optimized Nova-16 assembly code,
enabling native execution on the Nova-16 CPU emulator.
"""

import sys
import os
import re
from typing import Dict, List, Tuple, Optional, Set
from pathlib import Path

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from nova_cpu import CPU
from nova_memory import Memory
from nova_gfx import GFX
from nova_keyboard import NovaKeyboard
from nova_sound import NovaSound

# Import the optimizer
try:
    from forth_optimizer import ForthOptimizer
except ImportError:
    # Fallback if optimizer not available
    class ForthOptimizer:
        def optimize_assembly(self, lines): return lines
        def get_optimization_report(self): return "Optimizer not available"


class ForthCompiler:
    """
    Compiles FORTH source code to Nova-16 assembly.
    """

    def __init__(self, enable_optimization=True):
        # Initialize Nova-16 components for reference
        self.memory = Memory(0x10000)
        self.gfx = GFX()
        self.keyboard = NovaKeyboard()
        self.sound = NovaSound()
        self.sound.set_memory_reference(self.memory)
        self.cpu = CPU(self.memory, self.gfx, self.keyboard, self.sound)

        # Memory layout for compiled FORTH
        self.FORTH_START = 0x0120
        self.USER_START = 0x1000
        self.PARAM_STACK_START = 0xF000  # Grows downward
        self.RETURN_STACK_START = 0xFFFF  # Grows downward
        self.DICTIONARY_START = 0x0120

        # Compilation state
        self.assembly_lines: List[str] = []
        self.labels: Dict[str, int] = {}  # Label -> address
        self.label_counter = 0
        self.word_definitions: Dict[str, List[str]] = {}  # Word name -> assembly lines
        self.current_word: Optional[str] = None
        self.compiling = False
        self.control_stack: List[Tuple[str, str]] = []  # (type, label)
        
        # Variable and constant storage
        self.variables: Dict[str, int] = {}  # Variable name -> memory address
        self.constants: Dict[str, int] = {}  # Constant name -> value
        self.next_var_address = 0x2000  # Start variables at 0x2000

        # String storage
        self.string_counter = 0
        self.string_storage_base = 0x3000  # Base address for string storage
        
        # Stack management
        self.param_stack_depth = 0
        self.return_stack_depth = 0
        
        # Optimization
        self.enable_optimization = enable_optimization
        self.optimizer = ForthOptimizer() if enable_optimization else None

        # Initialize with standard header
        self._init_assembly_header()

    def _init_assembly_header(self):
        """Initialize the assembly file with standard FORTH setup"""
        self.assembly_lines = [
            "; FORTH Program - Generated by forth_compiler.py",
            "; Nova-16 Assembly Language",
            "",
            "ORG 0x1000",
            "",
            "; Initialize stacks",
            "MOV P8, 0xF000    ; Parameter stack pointer",
            "MOV P9, 0xFFFF    ; Return stack pointer",
            "",
            "; Main program entry point",
            "main:",
            "    CALL forth_main",
            "    HLT",
            "",
            "; FORTH main routine",
            "forth_main:",
            "    ; Initialize FORTH system",
            "    ; Main program code will be inserted here",
            "    RET",
            "",
            "; Print number routine (decimal output)",
            "print_number:",
            "    ; Convert 16-bit number in R0 to decimal and print",
            "    ; Handle negative numbers",
            "    MOV R1, R0",        # Copy number
            "    MOV R2, 0",         # Flag for negative
            "    JGE R1, positive",
            "    MOV R2, 1",         # Set negative flag
            "    NEG R1",            # Make positive
            "positive:",
            "    ; Convert to decimal digits",
            "    MOV P3, 10000",     # Start with 10000s place (use P register for 16-bit value)
            "    MOV R4, 0",         # Digit counter
            "convert_loop:",
            "    MOV R5, R1",        # Copy remaining value
            "    DIV R5, P3",        # Divide by current place
            "    ; R5 now contains the digit",
            "    CMP R5, 0",         # Compare digit with 0
            "    JZ skip_digit",     # Skip leading zeros
            "    MOV R4, 1",         # We've seen a non-zero digit
            "    ADD R5, 48",        # Convert to ASCII
            "    ; EMIT R5",         # Print digit (removed - no console output)
            "skip_digit:",
            "    ; Multiply remainder by current place and subtract",
            "    MUL R5, P3",        # R5 = digit * place (use P3)
            "    SUB R1, R5",        # R1 = R1 - (digit * place)
            "    ; Next place value",
            "    MOV R5, P3",        # Copy current place value
            "    DIV R5, 10",        # Divide by 10
            "    MOV P3, R5",        # Store new place value
            "    CMP P3, 0",         # Check if done
            "    JNZ convert_loop",
            "    ; Handle case where number was 0",
            "    CMP R4, 0",         # Compare digit counter with 0
            "    JNZ done_print",
            "    ; MOV R5, 48",      # ASCII '0' (removed - no console output)
            "    ; EMIT R5",         # Print '0' (removed - no console output)
            "done_print:",
            "    ; Print negative sign if needed",
            "    CMP R2, 0",         # Compare negative flag with 0
            "    JZ no_sign",
            "    ; MOV R5, 45",      # ASCII '-' (removed - no console output)
            "    ; EMIT R5",         # Print '-' (removed - no console output)
            "no_sign:",
            "    RET",
            "",
            "; Print string routine",
            "print_string:",
            "    ; Print string pointed to by R0",
            "    ; String format: length byte, string data, null terminator",
            "    MOV R1, [R0]",        # Get string length (first byte)",
            "    INC R0",              # Point to string data",
            "print_string_loop:",
            "    CMP R1, 0",           # Check if we've printed all characters",
            "    JZ print_string_done",
            "    MOV R2, [R0]",        # Get next character",
            "    ; EMIT R2",           # Print character (removed - no console output)",
            "    INC R0",              # Next character",
            "    DEC R1",              # Decrement counter",
            "    JMP print_string_loop",
            "print_string_done:",
            "    RET",
            "",
            "; Error handling routines",
            "stack_underflow:",
            "    ; Handle stack underflow error",
            "    ; For now, just halt (could be extended to print error message)",
            "    HLT",
            "",
            "stack_overflow:",
            "    ; Handle stack overflow error",
            "    ; For now, just halt (could be extended to print error message)",
            "    HLT",
            "",
            "; CR routine - print carriage return",
            "CR:",
            "    ; Print newline (simplified - just return)",
            "    RET",
            "",
        ]

    def _generate_unique_label(self, prefix: str = "L") -> str:
        """Generate a unique label"""
        self.label_counter += 1
        return f"{prefix}{self.label_counter}"

    def _push_param(self, value: int) -> List[str]:
        """Generate assembly to push value onto parameter stack"""
        lines = []
        if 0 <= value <= 255:
            # 8-bit values (like colors)
            lines.append(f"    MOV R0, {value}")
            lines.extend([
                "    SUB P8, 2",        # Proper arithmetic instruction for stack pointer
                "    MOV [P8+0], R0",   # Store 8-bit value using indexed addressing
            ])
        elif 0 <= value <= 65535:
            # 16-bit values (like coordinates)
            lines.append(f"    MOV P0, {value}")
            lines.extend([
                "    SUB P8, 2",        # Proper arithmetic instruction for stack pointer
                "    MOV [P8+0], P0",   # Store 16-bit value using indexed addressing
            ])
        else:
            # Handle larger values if needed
            lines.append(f"    MOV P0, {value & 0xFFFF}")
            lines.extend([
                "    SUB P8, 2",        # Proper arithmetic instruction for stack pointer
                "    MOV [P8+0], P0",   # Store value using indexed addressing
            ])
        self.param_stack_depth += 1
        return lines

    def _pop_param(self, dest: str = "P0", is_8bit: bool = False) -> List[str]:
        """Generate assembly to pop value from parameter stack"""
        if is_8bit:
            lines = [
                f"    MOV {dest}, [P8+0]",  # Load 8-bit value using indexed addressing
                "    ADD P8, 2",             # Proper arithmetic instruction for stack pointer
            ]
        else:
            lines = [
                f"    MOV {dest}, [P8+0]",  # Load 16-bit value using indexed addressing
                "    ADD P8, 2",             # Proper arithmetic instruction for stack pointer
            ]
        self.param_stack_depth -= 1
        return lines

    def _tokenize_forth(self, code: str) -> List[str]:
        """Tokenize FORTH source code"""
        tokens = []
        current_token = ""
        in_string = False

        i = 0
        while i < len(code):
            char = code[i]

            # Handle line comments with backslash
            if char == '\\' and not in_string:
                if current_token:
                    tokens.append(current_token)
                    current_token = ""
                while i < len(code) and code[i] != '\n':
                    i += 1
                continue

            # Handle parenthetical comments
            if char == '(' and not in_string:
                if current_token:
                    tokens.append(current_token)
                    current_token = ""
                paren_depth = 1
                i += 1
                while i < len(code) and paren_depth > 0:
                    if code[i] == '(':
                        paren_depth += 1
                    elif code[i] == ')':
                        paren_depth -= 1
                    i += 1
                i -= 1
            elif char == '"':
                if in_string:
                    current_token += char
                    tokens.append(current_token)
                    current_token = ""
                    in_string = False
                else:
                    if current_token:
                        tokens.append(current_token)
                        current_token = ""
                    current_token = char
                    in_string = True
            elif char == ';' and not in_string:
                if current_token:
                    tokens.append(current_token)
                    current_token = ""
                tokens.append(char)
            elif char == '.' and not in_string:
                if i + 1 < len(code) and code[i + 1] == '"':
                    if current_token:
                        tokens.append(current_token)
                        current_token = ""
                    current_token = '."'
                    in_string = True
                    i += 1
                else:
                    current_token += char
            elif char.isspace() and not in_string:
                if current_token:
                    tokens.append(current_token)
                    current_token = ""
            else:
                current_token += char

            i += 1

        if current_token:
            tokens.append(current_token)

        return tokens

    def _compile_token(self, token: str) -> List[str]:
        """Compile a single FORTH token to assembly"""
        lines = []

        # Handle numbers
        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):
            value = int(token)
            lines.extend(self._push_param(value))
        elif token.startswith('0x') or token.startswith('0X'):
            try:
                value = int(token, 16)
                lines.extend(self._push_param(value))
            except ValueError:
                lines.append(f"    ; Error: Invalid hex number {token}")
        elif token.startswith('$'):
            try:
                value = int(token[1:], 16)
                lines.extend(self._push_param(value))
            except ValueError:
                lines.append(f"    ; Error: Invalid hex number {token}")

        # Handle strings
        elif token.startswith('."') and token.endswith('"'):
            string_content = token[2:-1]
            lines.extend(self._compile_print_string(string_content))
        elif token.startswith('"') and token.endswith('"'):
            string_content = token[1:-1]
            lines.extend(self._compile_create_string(string_content))

        # Handle core FORTH words
        elif token == "DUP":
            lines.extend(self._compile_dup())
        elif token == "+":
            lines.extend(self._compile_add())
        elif token == "-":
            lines.extend(self._compile_sub())
        elif token == "*":
            lines.extend(self._compile_mul())
        elif token == "/":
            lines.extend(self._compile_div())
        elif token == ".":
            lines.extend(self._compile_dot())
        elif token == "DROP":
            lines.extend(self._compile_drop())
        elif token == "SWAP":
            lines.extend(self._compile_swap())
        elif token == "OVER":
            lines.extend(self._compile_over())
        elif token == "@":
            lines.extend(self._compile_fetch())
        elif token == "!":
            lines.extend(self._compile_store())
        elif token == "+!":
            lines.extend(self._compile_plus_store())
        elif token == "IF":
            lines.extend(self._compile_if())
        elif token == "ELSE":
            lines.extend(self._compile_else())
        elif token == "THEN":
            lines.extend(self._compile_then())
        elif token == "BEGIN":
            lines.extend(self._compile_begin())
        elif token == "UNTIL":
            lines.extend(self._compile_until())
        elif token == "AGAIN":
            lines.extend(self._compile_again())
        elif token == "DO":
            lines.extend(self._compile_do())
        elif token == "LOOP":
            lines.extend(self._compile_loop())
        elif token == "I":
            lines.extend(self._compile_i())
        elif token == "J":
            lines.extend(self._compile_j())
        elif token == "AND":
            lines.extend(self._compile_and())
        elif token == "=":
            lines.extend(self._compile_equals())
        elif token == "EXIT":
            lines.extend(self._compile_exit())
        elif token == "RECURSE":
            lines.append(f"    CALL {self.current_word}")

        # Nova-16 specific words
        elif token == "PIXEL":
            lines.extend(self._compile_pixel())
        elif token == "LAYER":
            lines.extend(self._compile_layer())
        elif token == "VMODE":
            lines.extend(self._compile_vmode())
        elif token == "PLAY":
            lines.extend(self._compile_play())
        elif token == "SOUND":
            lines.extend(self._compile_sound())
        elif token == "KEY":
            lines.extend(self._compile_key())
        elif token == "KEY?":
            lines.extend(self._compile_key_available())
        elif token == "SWRITE":
            lines.extend(self._compile_swrite())
        elif token == "SPRITE":
            lines.extend(self._compile_sprite())
        elif token == "VX!":
            lines.extend(self._compile_vx_store())
        elif token == "VY!":
            lines.extend(self._compile_vy_store())
        elif token == "VM!":
            lines.extend(self._compile_vm_store())
        elif token == "VL!":
            lines.extend(self._compile_vl_store())
        elif token == "TIMER!":
            lines.extend(self._compile_timer_store())

        else:
            # Check if it's a defined variable or constant
            if token in self.variables:
                lines.extend(self._compile_variable_access(token))
            elif token in self.constants:
                lines.extend(self._compile_constant_access(token))
            else:
                # Assume it's a user-defined word
                lines.append(f"    CALL {token}")

        return lines

    # Core FORTH word implementations
    def _compile_dup(self) -> List[str]:
        return [
            "    ; DUP",
            "    MOV R0, [P8+0]",      # Get top of stack using indexed addressing
            "    SUB P8, 2",           # Make room for duplicate using proper arithmetic
            "    MOV [P8+0], R0",      # Store duplicate using indexed addressing
        ]

    def _compile_add(self) -> List[str]:
        return [
            "    ; +",
            "    MOV R0, [P8+0]",      # Get first operand using indexed addressing
            "    MOV R1, [P8+2]",      # Get second operand using indexed addressing
            "    ADD P8, 2",           # Adjust stack pointer (pop one operand)
            "    ADD R1, R0",          # Add them
            "    MOV [P8+0], R1",      # Store result using indexed addressing
        ]

    def _compile_sub(self) -> List[str]:
        return [
            "    ; -",
            "    MOV R0, [P8+0]",     # Get first operand using indexed addressing
            "    MOV R1, [P8+2]",     # Get second operand using indexed addressing
            "    ADD P8, 2",          # Adjust stack pointer (pop one operand)
            "    SUB R1, R0",         # Subtract (second - first)
            "    MOV [P8+0], R1",     # Store result using indexed addressing
        ]

    def _compile_mul(self) -> List[str]:
        return [
            "    ; *",
            "    MOV R0, [P8+0]",     # Get first operand using indexed addressing
            "    MOV R1, [P8+2]",     # Get second operand using indexed addressing
            "    ADD P8, 2",          # Adjust stack pointer (pop one operand)
            "    MUL R1, R0",         # Multiply them
            "    MOV [P8+0], R1",     # Store result using indexed addressing
        ]

    def _compile_div(self) -> List[str]:
        return [
            "    ; /",
            "    MOV P0, [P8+0]",     # Get first operand using indexed addressing
            "    MOV P1, [P8+2]",     # Get second operand using indexed addressing
            "    ADD P8, 2",          # Adjust stack pointer (pop one operand)
            "    DIV P1, P0",         # Divide (second / first)
            "    MOV [P8+0], P1",     # Store result using indexed addressing
        ]

    def _compile_dot(self) -> List[str]:
        return [
            "    ; .",
            "    MOV R0, [P8+0]",     # Get number using indexed addressing
            "    ADD P8, 2",          # Pop from stack using proper arithmetic
            "    CALL print_number",  # Call print routine
        ]

    def _compile_drop(self) -> List[str]:
        return [
            "    ; DROP",
            "    ADD P8, 2",          # Pop one item using proper arithmetic
        ]

    def _compile_swap(self) -> List[str]:
        return [
            "    ; SWAP",
            "    MOV R0, [P8+0]",     # Get first using indexed addressing
            "    MOV R1, [P8+2]",     # Get second using indexed addressing
            "    MOV [P8+0], R1",     # Store second in first's position
            "    MOV [P8+2], R0",     # Store first in second's position
        ]

    def _compile_over(self) -> List[str]:
        return [
            "    ; OVER",
            "    MOV R0, [P8+2]",     # Get second item using indexed addressing
            "    SUB P8, 2",          # Make room using proper arithmetic
            "    MOV [P8+0], R0",     # Push copy of second item using indexed addressing
        ]

    def _compile_fetch(self) -> List[str]:
        return [
            "    ; @",
            "    MOV R0, [P8+0]",     # Get address using indexed addressing
            "    MOV R0, [R0+0]",     # Fetch value from address using indexed addressing
            "    MOV [P8+0], R0",     # Store value back on stack using indexed addressing
        ]

    def _compile_store(self) -> List[str]:
        return [
            "    ; !",
            "    MOV R0, [P8+0]",     # Get address using indexed addressing
            "    MOV R1, [P8+2]",     # Get value using indexed addressing
            "    ADD P8, 4",          # Pop both items using proper arithmetic
            "    MOV [R0+0], R1",     # Store value to address using indexed addressing
        ]

    def _compile_plus_store(self) -> List[str]:
        return [
            "    ; +!",
            "    MOV R0, [P8+0]",     # Get address using indexed addressing
            "    MOV R1, [P8+2]",     # Get value to add using indexed addressing
            "    ADD P8, 4",          # Pop both items using proper arithmetic
            "    MOV R2, [R0+0]",     # Fetch current value using indexed addressing
            "    ADD R2, R1",         # Add the value
            "    MOV [R0+0], R2",     # Store result back using indexed addressing
        ]

    # Control flow implementations
    def _compile_if(self) -> List[str]:
        else_label = self._generate_unique_label("else")
        then_label = self._generate_unique_label("then")
        self.control_stack.append(("if", then_label, else_label))
        
        return [
            "    ; IF",
            "    MOV R0, [P8+0]",     # Get condition using indexed addressing
            "    ADD P8, 2",          # Pop condition using proper arithmetic
            "    CMP R0, 0",          # Test condition
            f"    JZ {else_label}",   # Jump to else if false
        ]

    def _compile_else(self) -> List[str]:
        if not self.control_stack or self.control_stack[-1][0] != "if":
            return ["    ; Error: ELSE without matching IF"]
        
        _, then_label, else_label = self.control_stack[-1]
        return [
            f"    JMP {then_label}",  # Jump to end
            f"{else_label}:",         # Start of else clause
        ]

    def _compile_then(self) -> List[str]:
        if not self.control_stack or self.control_stack[-1][0] != "if":
            return ["    ; Error: THEN without matching IF"]
        
        _, then_label, else_label = self.control_stack.pop()
        return [
            f"{then_label}:",      # End of conditional
            f"{else_label}:",      # Also mark else label if not used
        ]

    def _compile_begin(self) -> List[str]:
        begin_label = self._generate_unique_label("begin")
        self.control_stack.append(("begin", begin_label))
        
        return [
            f"{begin_label}:",     # Loop start
        ]

    def _compile_until(self) -> List[str]:
        if not self.control_stack or self.control_stack[-1][0] != "begin":
            return ["    ; Error: UNTIL without matching BEGIN"]
        
        _, begin_label = self.control_stack.pop()
        return [
            "    ; UNTIL",
            "    MOV R0, [P8+0]",     # Get condition using indexed addressing
            "    ADD P8, 2",          # Pop condition using proper arithmetic
            "    CMP R0, 0",          # Test condition
            f"    JZ {begin_label}",  # Jump back if false (continue loop)
        ]

    def _compile_again(self) -> List[str]:
        if not self.control_stack or self.control_stack[-1][0] != "begin":
            return ["    ; Error: AGAIN without matching BEGIN"]
        
        _, begin_label = self.control_stack.pop()
        return [
            f"    JMP {begin_label}",  # Unconditional jump back
        ]

    def _compile_do(self) -> List[str]:
        do_label = self._generate_unique_label("do")
        loop_label = self._generate_unique_label("loop_end")
        self.control_stack.append(("do", do_label, loop_label))
        
        return [
            "    ; DO (limit index DO)",
            "    MOV R0, [P8+0]",     # Get index using indexed addressing
            "    MOV R1, [P8+2]",     # Get limit using indexed addressing
            "    ADD P8, 4",          # Pop both items using proper arithmetic
            "    ; Push to return stack for loop control",
            "    SUB P9, 2",          # Make room on return stack using proper arithmetic
            "    MOV [P9+0], R1",     # Push limit to return stack using indexed addressing
            "    SUB P9, 2",          # Make room on return stack using proper arithmetic
            "    MOV [P9+0], R0",     # Push index to return stack using indexed addressing
            f"{do_label}:",           # Loop start
        ]

    def _compile_loop(self) -> List[str]:
        if not self.control_stack or self.control_stack[-1][0] != "do":
            return ["    ; Error: LOOP without matching DO"]
        
        _, do_label, loop_label = self.control_stack.pop()
        return [
            "    ; LOOP",
            "    MOV R0, [P9+0]",   # Get current index using indexed addressing
            "    INC R0",           # Increment index
            "    MOV [P9+0], R0",   # Store back using indexed addressing
            "    MOV R1, [P9+2]",   # Get limit using indexed addressing
            "    CMP R0, R1",       # Compare index with limit
            f"    JL {do_label}",   # Continue if index < limit
            "    ; Clean up return stack",
            "    ADD P9, 4",        # Remove both index and limit using proper arithmetic
            f"{loop_label}:",       # End of loop
        ]

    def _compile_i(self) -> List[str]:
        return [
            "    ; I - Get loop index",
            "    MOV R0, [P9+0]",     # Get index from return stack using indexed addressing
            "    SUB P8, 2",          # Make room on parameter stack using proper arithmetic
            "    MOV [P8+0], R0",     # Push to parameter stack using indexed addressing
        ]

    def _compile_j(self) -> List[str]:
        return [
            "    ; J - Get outer loop index",
            "    MOV R0, [P9+4]",     # Get outer index from return stack using indexed addressing
            "    SUB P8, 2",          # Make room on parameter stack using proper arithmetic
            "    MOV [P8+0], R0",     # Push to parameter stack using indexed addressing
        ]

    def _compile_and(self) -> List[str]:
        return [
            "    ; AND",
            "    MOV R0, [P8+0]",     # Get first operand using indexed addressing
            "    MOV R1, [P8+2]",     # Get second operand using indexed addressing
            "    ADD P8, 2",          # Pop one operand using proper arithmetic
            "    AND R0, R1",         # Bitwise AND
            "    MOV [P8+0], R0",     # Store result using indexed addressing
        ]

    def _compile_equals(self) -> List[str]:
        true_label = self._generate_unique_label("eq_true")
        end_label = self._generate_unique_label("eq_end")
        
        return [
            "    ; =",
            "    MOV R0, [P8+0]",     # Get first operand using indexed addressing
            "    MOV R1, [P8+2]",     # Get second operand using indexed addressing
            "    ADD P8, 2",          # Pop one operand using proper arithmetic
            "    CMP R0, R1",         # Compare values
            f"    JZ {true_label}",
            "    MOV R0, 0",          # False
            f"    JMP {end_label}",
            f"{true_label}:",
            "    MOV R0, -1",         # True (FORTH uses -1 for true)
            f"{end_label}:",
            "    MOV [P8+0], R0",     # Store result using indexed addressing
        ]

    def _compile_exit(self) -> List[str]:
        return [
            "    ; EXIT",
            "    RET",
        ]

    # Nova-16 specific implementations
    def _compile_pixel(self) -> List[str]:
        lines = [
            "    ; PIXEL - Draw at (x,y) with color",
            "    ; Stack before: ( x y color -- )",
        ]
        lines.extend(self._pop_param("P2", is_8bit=False))  # Color
        lines.extend([
            "    MOV R0, :P2",    # Extract low byte (the actual color value)
        ])
        lines.extend(self._pop_param("P0"))  # Y coordinate
        lines.extend([
            "    MOV R1, :P0",    # Extract low byte (the actual Y coordinate)
        ])
        lines.extend(self._pop_param("P1"))  # X coordinate
        lines.extend([
            "    ; Set coordinates to video registers",
            "    MOV VX, :P1",    # Low byte of X coordinate
            "    MOV VY, R1",     # Y coordinate  
            "    ; Write the pixel",
            "    SWRITE R0",
        ])
        return lines

    def _compile_layer(self) -> List[str]:
        lines = [
            "    ; LAYER - Set active graphics layer",
            "    ; Stack before: ( layer -- )",
        ]
        lines.extend(self._pop_param("P0", is_8bit=False))
        lines.extend([
            "    MOV R0, :P0",    # Extract low byte
            "    MOV VL, R0",     # Set video layer register
        ])
        return lines

    def _compile_vmode(self) -> List[str]:
        return [
            "    ; VMODE - Set video mode",
            "    ; Stack before: ( mode -- )",
            "    MOV R0, [P8+0]",     # Get mode using indexed addressing
            "    ADD P8, 2",          # Pop mode using proper arithmetic
            "    MOV VM, R0",         # Set video mode register
        ]

    def _compile_play(self) -> List[str]:
        return [
            "    ; PLAY - Start sound playback",
            "    SPLAY",            # Nova-16 sound play instruction
        ]

    def _compile_sound(self) -> List[str]:
        return [
            "    ; SOUND - Set sound parameters",
            "    ; Stack before: ( freq volume waveform -- )",
            "    MOV R0, [P8+0]",     # Get waveform using indexed addressing
            "    MOV SW, R0",         # Set waveform
            "    MOV R0, [P8+2]",     # Get volume using indexed addressing
            "    MOV SV, R0",         # Set volume
            "    MOV R0, [P8+4]",     # Get frequency using indexed addressing
            "    ADD P8, 6",          # Pop all three items using proper arithmetic
            "    MOV SF, R0",         # Set frequency
        ]

    def _compile_key(self) -> List[str]:
        return [
            "    ; KEY - Read key from keyboard",
            "    KEYIN R0",         # Read key into R0
            "    SUB P8, 2",        # Make room on stack using proper arithmetic
            "    MOV [P8+0], R0",   # Push key to stack using indexed addressing
        ]

    def _compile_key_available(self) -> List[str]:
        return [
            "    ; KEY? - Check if key is available",
            "    KEYSTAT R0",       # Check key status
            "    SUB P8, 2",        # Make room on stack using proper arithmetic
            "    MOV [P8+0], R0",   # Push status to stack using indexed addressing
        ]

    def _compile_swrite(self) -> List[str]:
        lines = [
            "    ; SWRITE - Write pixel at current coordinates",
            "    ; Stack before: ( color -- )",
        ]
        lines.extend(self._pop_param("P0", is_8bit=False))
        lines.extend([
            "    MOV R0, :P0",    # Extract low byte (color)
            "    SWRITE R0",     # Write pixel
        ])
        return lines

    def _compile_sprite(self) -> List[str]:
        lines = [
            "    ; SPRITE - Configure sprite",
            "    ; Stack before: ( sprite_id x y color -- )",
        ]
        lines.extend(self._pop_param("P0", is_8bit=False))  # Color
        lines.extend(self._pop_param("P1", is_8bit=False))  # Y
        lines.extend(self._pop_param("P2", is_8bit=False))  # X  
        lines.extend(self._pop_param("P3", is_8bit=False))  # Sprite ID
        
        lines.extend([
            "    ; Calculate sprite control block address",
            "    MOV R0, :P3",      # Sprite ID (low byte)
            "    AND R0, 0x0F",     # Limit to 16 sprites (0-15)
            "    SHL R0",           # R0 = ID * 2
            "    SHL R0",           # R0 = ID * 4  
            "    SHL R0",           # R0 = ID * 8
            "    SHL R0",           # R0 = ID * 16
            "    ADD R0, 0xF000",   # Base address of sprite control blocks",
            "",
            "    ; Store sprite parameters in control block",
            "    MOV R1, :P2",      # X coordinate
            "    MOV [R0+0], R1",   # Store X at offset 0 using indexed addressing
            "    MOV R1, :P1",      # Y coordinate  
            "    MOV [R0+1], R1",   # Store Y at offset 1 using indexed addressing
            "    MOV R1, :P0",      # Color
            "    MOV [R0+2], R1",   # Store color at offset 2 using indexed addressing
            "    MOV R1, 1",        # Enable sprite
            "    MOV [R0+3], R1",   # Store enable flag at offset 3 using indexed addressing,
        ])
        return lines

    def _compile_vx_store(self) -> List[str]:
        lines = [
            "    ; VX! - Store to VX register", 
            "    ; Stack before: ( value -- )",
        ]
        lines.extend(self._pop_param("P0", is_8bit=False))
        lines.extend([
            "    MOV R0, :P0",    # Extract low byte
            "    MOV VX, R0",     # Set VX register
        ])
        return lines

    def _compile_vy_store(self) -> List[str]:
        lines = [
            "    ; VY! - Store to VY register",
            "    ; Stack before: ( value -- )",
        ]
        lines.extend(self._pop_param("P0", is_8bit=False))
        lines.extend([
            "    MOV R0, :P0",    # Extract low byte
            "    MOV VY, R0",     # Set VY register
        ])
        return lines

    def _compile_vm_store(self) -> List[str]:
        lines = [
            "    ; VM! - Store to VM register (video mode)",
            "    ; Stack before: ( mode -- )",
        ]
        lines.extend(self._pop_param("P0", is_8bit=False))
        lines.extend([
            "    MOV R0, :P0",    # Extract low byte
            "    MOV VM, R0",     # Set VM register
        ])
        return lines

    def _compile_vl_store(self) -> List[str]:
        lines = [
            "    ; VL! - Store to VL register (video layer)",
            "    ; Stack before: ( layer -- )",
        ]
        lines.extend(self._pop_param("P0", is_8bit=False))
        lines.extend([
            "    MOV R0, :P0",    # Extract low byte
            "    MOV VL, R0",     # Set VL register
        ])
        return lines

    def _compile_timer_store(self) -> List[str]:
        lines = [
            "    ; TIMER! - Store to timer register",
            "    ; Stack before: ( value -- )",
        ]
        lines.extend(self._pop_param("P0", is_8bit=False))
        lines.extend([
            "    MOV TT, P0",      # Set timer register (16-bit)
        ])
        return lines

    # String handling
    def _compile_print_string(self, string_content: str) -> List[str]:
        lines = [
            f"    ; Print string: \"{string_content}\"",
            f"    ; Create string at runtime address",
            f"    MOV P0, {self.string_storage_base + self.string_counter * 64}",
        ]
        
        # Store string length first
        lines.extend([
            f"    MOV R0, {len(string_content)}",
            f"    MOV [P0], R0",
            f"    INC P0",
        ])
        
        # Store each character
        for char in string_content:
            lines.extend([
                f"    MOV R0, {ord(char)}",
                f"    MOV [P0], R0", 
                f"    INC P0",
            ])
        
        # Store null terminator and print
        lines.extend([
            f"    MOV R0, 0",
            f"    MOV [P0], R0",
            f"    MOV R0, {self.string_storage_base + self.string_counter * 64}",
            f"    CALL print_string",
        ])
        self.string_counter += 1
        return lines

    def _compile_create_string(self, string_content: str) -> List[str]:
        lines = [
            f"    ; String: \"{string_content}\"",
            f"    MOV P0, {self.string_storage_base + self.string_counter * 64}",
        ]
        
        # Store string length first
        lines.extend([
            f"    MOV R0, {len(string_content)}",
            f"    MOV [P0], R0",
            f"    INC P0",
        ])
        
        # Store each character
        for char in string_content:
            lines.extend([
                f"    MOV R0, {ord(char)}",
                f"    MOV [P0], R0",
                f"    INC P0",
            ])
        
        # Store null terminator and push address
        lines.extend([
            f"    MOV R0, 0",
            f"    MOV [P0], R0",
            f"    MOV R0, {self.string_storage_base + self.string_counter * 64}",
            "    SUB P8, 2",        # Make room on stack using proper arithmetic
            "    MOV [P8+0], R0"    # Push address using indexed addressing
        ])
        self.string_counter += 1
        return lines

    # Variable and constant access
    def _compile_variable_access(self, name: str) -> List[str]:
        address = self.variables[name]
        return [
            f"    ; Variable access: {name}",
            f"    MOV P0, {address}",
            "    SUB P8, 2",          # Proper arithmetic instruction
            "    MOV [P8+0], P0",     # Store using indexed addressing
        ]

    def _compile_constant_access(self, name: str) -> List[str]:
        value = self.constants[name]
        return [
            f"    ; Constant access: {name}",
            f"    MOV P0, {value}",
            "    SUB P8, 2",          # Proper arithmetic instruction
            "    MOV [P8+0], P0",     # Store using indexed addressing
        ]

    # Main compilation methods
    def compile_word(self, word_name: str, forth_code: str) -> List[str]:
        """Compile a FORTH word definition to assembly with proper frame management"""
        self.current_word = word_name
        self.compiling = True
        self.control_stack = []

        lines = [
            f"; Word: {word_name}",
            f"{word_name}:",
            "    ; Function prologue - Nova-16 frame management",
            "    SUB P9, 2",          # Make room on return stack
            "    MOV [P9+0], P9",     # Save caller's frame pointer (recursive save)
            "    MOV P9, P8",         # Set new frame pointer to current stack position
        ]

        tokens = self._tokenize_forth(forth_code)
        for token in tokens:
            word_lines = self._compile_token(token)
            lines.extend(word_lines)

        # Function epilogue
        lines.extend([
            "    ; Function epilogue - restore frame",
            "    MOV P8, P9",         # Restore stack pointer
            "    MOV P9, [P9+0]",     # Restore caller's frame pointer
            "    ADD P9, 2",          # Clean up return stack
            "    RET"
        ])
        lines.append("")

        self.compiling = False
        self.current_word = None
        return lines

    def _tokenize(self, forth_source: str) -> List[str]:
        """Tokenize FORTH source code into tokens"""
        return self._tokenize_forth(forth_source)
    
    def _parse_tokens(self, tokens: List[str]):
        """Parse and compile FORTH tokens"""
        i = 0
        while i < len(tokens):
            token = tokens[i]
            
            if token == ':':
                # Word definition
                if i + 1 < len(tokens):
                    word_name = tokens[i + 1]
                    j = i + 2
                    while j < len(tokens) and tokens[j] != ';':
                        j += 1
                    if j < len(tokens):
                        word_body = ' '.join(tokens[i + 2:j])
                        word_assembly = self.compile_word(word_name, word_body)
                        self.assembly_lines.extend(word_assembly)
                        self.word_definitions[word_name] = word_assembly
                        i = j + 1
                        continue
                    else:
                        self.assembly_lines.append(f"    ; Error: Missing ; for word {word_name}")
                        i += 1
                else:
                    self.assembly_lines.append("    ; Error: Missing word name after :")
                    i += 1
            elif token == 'VARIABLE':
                if i + 1 < len(tokens):
                    var_name = tokens[i + 1]
                    self.variables[var_name] = self.next_var_address
                    self.assembly_lines.extend([
                        f"; Variable: {var_name}",
                        f"{var_name}_addr: DW {self.next_var_address}",
                        f"    ; Reserve space at {self.next_var_address}",
                        ""
                    ])
                    self.next_var_address += 2
                    i += 2
                else:
                    self.assembly_lines.append("    ; Error: Missing variable name after VARIABLE")
                    i += 1
            elif token == 'CONSTANT':
                if i + 1 < len(tokens):
                    const_name = tokens[i + 1]
                    self.constants[const_name] = 0  # Default value
                    self.assembly_lines.extend([
                        f"; Constant: {const_name}",
                        f"{const_name}_value EQU 0",
                        ""
                    ])
                    i += 2
                else:
                    self.assembly_lines.append("    ; Error: Missing constant name after CONSTANT")
                    i += 1
            else:
                # Handle main program tokens
                if token not in [':', ';']:
                    main_code_lines = self._compile_token(token)
                    if main_code_lines:
                        # Insert into forth_main routine
                        for j, line in enumerate(self.assembly_lines):
                            if "forth_main:" in line:
                                for k in range(j, len(self.assembly_lines)):
                                    if "    RET" in self.assembly_lines[k] and "forth_main" in self.assembly_lines[j:k+1]:
                                        for line_to_insert in reversed(main_code_lines):
                                            self.assembly_lines.insert(k, line_to_insert)
                                        break
                                break
                i += 1

    def compile_program(self, forth_source: str, output_file: str):
        """Compile FORTH source code to assembly"""
        tokens = self._tokenize(forth_source)
        self._parse_tokens(tokens)
        
        if self.enable_optimization:
            self.assembly_lines = self.optimizer.optimize_assembly(self.assembly_lines)
        
        with open(output_file, 'w') as f:
            f.write('\n'.join(self.assembly_lines))
        
        if self.enable_optimization:
            print("FORTH Compiler Optimization Report")
            print("==================================")
    
    def compile_to_lines(self, forth_source: str) -> list:
        """Compile FORTH source code to assembly lines without writing file"""
        tokens = self._tokenize(forth_source)
        self._parse_tokens(tokens)
        
        if self.enable_optimization:
            return self.optimizer.optimize_assembly(self.assembly_lines)
        
        return self.assembly_lines


def main():
    if len(sys.argv) != 3:
        print("Usage: python forth_compiler.py <input.forth> <output.asm>")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    with open(input_file, 'r') as f:
        forth_source = f.read()
    
    compiler = ForthCompiler()
    compiler.compile_program(forth_source, output_file)
    print(f"Compiled FORTH program to {output_file}")


if __name__ == "__main__":
    main()
