; FORTH Program - Generated by forth_compiler.py
; Nova-16 Assembly Language

ORG 0x1000

; Initialize stacks
MOV P8, 0xF000    ; Parameter stack pointer
MOV P9, 0xFFFF    ; Return stack pointer

; Main program entry point
main:
    CALL forth_main
    HLT

; FORTH main routine
forth_main:
    ; Initialize FORTH system
    ; Main program
        MOV R0, 0
        DEC P8
        DEC P8
        MOV [P8], R0
        ; VMODE - Set video mode
        ; Stack before: ( mode -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV R0, :P0
        MOV VM, R0
        MOV R0, 1
        DEC P8
        DEC P8
        MOV [P8], R0
        ; LAYER - Set active graphics layer
        ; Stack before: ( layer -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV R0, :P0
        MOV VL, R0
        MOV R0, 50
        DEC P8
        DEC P8
        MOV [P8], R0
        ; VX! - Store to VX register
        ; Stack before: ( value -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV R0, :P0
        MOV VX, R0
        MOV R0, 60
        DEC P8
        DEC P8
        MOV [P8], R0
        ; VY! - Store to VY register
        ; Stack before: ( value -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV R0, :P0
        MOV VY, R0
        MOV R0, 15
        DEC P8
        DEC P8
        MOV [P8], R0
        ; SWRITE - Write pixel at current coordinates
        ; Stack before: ( color -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV R0, :P0
        SWRITE R0
        MOV R0, 0
        DEC P8
        DEC P8
        MOV [P8], R0
        MOV R0, 10
        DEC P8
        DEC P8
        MOV [P8], R0
        MOV R0, 20
        DEC P8
        DEC P8
        MOV [P8], R0
        MOV R0, 12
        DEC P8
        DEC P8
        MOV [P8], R0
        ; SPRITE - Configure sprite
        ; Stack before: ( sprite_id x y color -- )
        ; Sprite control blocks at 0xF000-0xF0FF (16 sprites × 16 bytes)
        MOV P0, [P8]
        INC P8
        INC P8
        MOV P1, [P8]
        INC P8
        INC P8
        MOV P2, [P8]
        INC P8
        INC P8
        MOV P3, [P8]
        INC P8
        INC P8
        ; Calculate sprite control block address
        MOV R0, :P3
        AND R0, 0x0F
        ; Multiply by 16 using shifts: 16 = 2^4
        SHL R0
        SHL R0
        SHL R0
        SHL R0
        ADD R0, 0xF000
    
        ; Store sprite parameters in control block
        MOV R1, :P2
        MOV [R0], R1
        INC R0
        MOV R1, :P1
        MOV [R0], R1
        INC R0
        MOV R1, :P0
        MOV [R0], R1
        INC R0
        MOV R1, 1
        MOV [R0], R1
        MOV R0, 0
        DEC P8
        DEC P8
        MOV [P8], R0
        ; SPRITEBLOCK - Get sprite control block address
        ; Stack before: ( sprite_id -- addr )
        MOV P0, [P8]
        INC P8
        INC P8
        ; Calculate sprite control block address
        MOV R0, :P0
        AND R0, 0x0F
        ; Multiply by 16 using shifts: 16 = 2^4
        SHL R0
        SHL R0
        SHL R0
        SHL R0
        ADD R0, 0xF000
        ; Push address to stack
        DEC P8
        DEC P8
        MOV [P8], R0
        MOV R0, 42
        DEC P8
        DEC P8
        MOV [P8], R0
        ; SWAP
        MOV R0, [P8]
        INC P8
        INC P8
        MOV R1, [P8]
        MOV [P8], R0
        DEC P8
        DEC P8
        MOV [P8], R1
        ; !
        MOV R0, [P8]
        INC P8
        INC P8
        MOV R1, [P8]
        INC P8
        INC P8
        MOV [R0], R1
        MOV P0, 32768
        DEC P8
        DEC P8
        MOV [P8], P0
        MOV R0, 5
        DEC P8
        DEC P8
        MOV [P8], R0
        ; GFXMEM - Direct graphics memory access
        ; Stack before: ( addr color -- )
        ; Direct memory write for graphics
        MOV P0, [P8]
        INC P8
        INC P8
        MOV P1, [P8]
        INC P8
        INC P8
        ; Direct memory write
        MOV R0, :P0
        MOV [P1], R0
        MOV P0, 440
        DEC P8
        DEC P8
        MOV [P8], P0
        MOV R0, 128
        DEC P8
        DEC P8
        MOV [P8], R0
        MOV R0, 1
        DEC P8
        DEC P8
        MOV [P8], R0
        ; SOUNDREG - Advanced sound register access
        ; Stack before: ( freq volume waveform -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV P1, [P8]
        INC P8
        INC P8
        MOV P2, [P8]
        INC P8
        INC P8
        ; Set sound registers
        MOV SF, P2
        MOV R0, :P1
        MOV SV, R0
        MOV R0, :P0
        MOV SW, R0
        MOV P0, 1000
        DEC P8
        DEC P8
        MOV [P8], P0
        ; TIMER! - Store to timer register
        ; Stack before: ( value -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV TT, P0
        MOV R0, 1
        DEC P8
        DEC P8
        MOV [P8], R0
        ; VM! - Store to VM register (video mode)
        ; Stack before: ( mode -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV R0, :P0
        MOV VM, R0
        MOV P0, 36864
        DEC P8
        DEC P8
        MOV [P8], P0
        ; VX! - Store to VX register
        ; Stack before: ( value -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV R0, :P0
        MOV VX, R0
        MOV R0, 7
        DEC P8
        DEC P8
        MOV [P8], R0
        ; SWRITE - Write pixel at current coordinates
        ; Stack before: ( color -- )
        MOV P0, [P8]
        INC P8
        INC P8
        MOV R0, :P0
        SWRITE R0
        ; Print string: " Enhanced graphics test complete!"
        ; Create string at runtime address
        MOV P0, 12288
        MOV R0, 33
        MOV [P0], R0
        INC P0
        MOV R0, 32
        MOV [P0], R0
        INC P0
        MOV R0, 69
        MOV [P0], R0
        INC P0
        MOV R0, 110
        MOV [P0], R0
        INC P0
        MOV R0, 104
        MOV [P0], R0
        INC P0
        MOV R0, 97
        MOV [P0], R0
        INC P0
        MOV R0, 110
        MOV [P0], R0
        INC P0
        MOV R0, 99
        MOV [P0], R0
        INC P0
        MOV R0, 101
        MOV [P0], R0
        INC P0
        MOV R0, 100
        MOV [P0], R0
        INC P0
        MOV R0, 32
        MOV [P0], R0
        INC P0
        MOV R0, 103
        MOV [P0], R0
        INC P0
        MOV R0, 114
        MOV [P0], R0
        INC P0
        MOV R0, 97
        MOV [P0], R0
        INC P0
        MOV R0, 112
        MOV [P0], R0
        INC P0
        MOV R0, 104
        MOV [P0], R0
        INC P0
        MOV R0, 105
        MOV [P0], R0
        INC P0
        MOV R0, 99
        MOV [P0], R0
        INC P0
        MOV R0, 115
        MOV [P0], R0
        INC P0
        MOV R0, 32
        MOV [P0], R0
        INC P0
        MOV R0, 116
        MOV [P0], R0
        INC P0
        MOV R0, 101
        MOV [P0], R0
        INC P0
        MOV R0, 115
        MOV [P0], R0
        INC P0
        MOV R0, 116
        MOV [P0], R0
        INC P0
        MOV R0, 32
        MOV [P0], R0
        INC P0
        MOV R0, 99
        MOV [P0], R0
        INC P0
        MOV R0, 111
        MOV [P0], R0
        INC P0
        MOV R0, 109
        MOV [P0], R0
        INC P0
        MOV R0, 112
        MOV [P0], R0
        INC P0
        MOV R0, 108
        MOV [P0], R0
        INC P0
        MOV R0, 101
        MOV [P0], R0
        INC P0
        MOV R0, 116
        MOV [P0], R0
        INC P0
        MOV R0, 101
        MOV [P0], R0
        INC P0
        MOV R0, 33
        MOV [P0], R0
        INC P0
        MOV R0, 0
        MOV [P0], R0
        ; Print the string
        MOV R0, 12288
        CALL print_string
        CALL CR
    RET

; Print number routine (decimal output)
    ; Convert 16-bit number in R0 to decimal and print
    ; Handle negative numbers
    MOV R1, R0
    MOV R2, 0
    JGE R1, positive
    MOV R2, 1
    NEG R1
positive:
    ; Convert to decimal digits
    MOV P3, 10000
    MOV R4, 0
convert_loop:
    MOV R5, R1
    DIV R5, P3
    ; R5 now contains the digit
    CMP R5, 0
    JZ skip_digit
    MOV R4, 1
    ADD R5, 48
    ; EMIT R5
skip_digit:
    ; Multiply remainder by current place and subtract
    MUL R5, P3
    SUB R1, R5
    ; Next place value
    MOV R5, P3
    DIV R5, 10
    MOV P3, R5
    CMP P3, 0
    JNZ convert_loop
    ; Handle case where number was 0
    CMP R4, 0
    JNZ done_print
    ; MOV R5, 48
    ; EMIT R5
done_print:
    ; Print negative sign if needed
    CMP R2, 0
    JZ no_sign
    ; MOV R5, 45
    ; EMIT R5
no_sign:
    RET

; Print string routine
print_string:
    ; Print string pointed to by R0
    ; String format: length byte, string data, null terminator
    MOV R1, [R0]
    INC R0
print_string_loop:
    CMP R1, 0
    JZ print_string_done
    MOV R2, [R0]
    ; EMIT R2
    INC R0
    DEC R1
    JMP print_string_loop
print_string_done:
    RET

; Error handling routines
    ; Handle stack underflow error
    ; For now, just halt (could be extended to print error message)
    HLT

    ; Handle stack overflow error
    ; For now, just halt (could be extended to print error message)
    HLT

; CR routine - print carriage return
CR:
    ; Print newline (simplified - just return)
    RET
