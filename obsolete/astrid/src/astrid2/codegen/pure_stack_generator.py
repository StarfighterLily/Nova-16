"""
Pure Stack-Centric Code Generator for Astrid
Implements a truly stack-first approach for Nova-16, minimizing register usage
and maximizing use of stack operations for all variable storage and computation.
"""

import logging
from typing import Dict, List, Optional, Set, Tuple
from ..ir.builder import IRModule, IRFunction, IRInstruction
from ..utils.logger import get_logger
from ..builtin.graphics import GraphicsBuiltins
from ..builtin.sound import SoundBuiltins
from ..builtin.string import StringBuiltins
from ..builtin.system import SystemBuiltins

logger = get_logger(__name__)


class StackFrame:
    """Manages pure stack-based variable layout for a function."""
    
    def __init__(self, function_name: str):
        self.function_name = function_name
        self.variables = {}        # var_name -> stack_offset_from_fp
        self.parameters = {}       # param_name -> stack_offset_from_fp
        self.current_local_offset = -2  # Start allocating locals below FP
        self.max_locals_size = 0   # Total size needed for locals
        
    def add_parameter(self, name: str, param_index: int, param_type: str = 'int16') -> int:
        """Add a parameter at its stack location above FP."""
        # Parameters are above FP: FP+4 (first param), FP+6 (second param), etc.
        offset = 4 + (param_index * 2)  # 2 bytes per parameter
        self.parameters[name] = offset
        logger.debug(f"Parameter {name} at FP+{offset}")
        return offset
        
    def add_local_variable(self, name: str, var_type: str = 'int16') -> int:
        """Add a local variable below FP."""
        size = 2 if var_type == 'int16' else 1
        
        # Align to 2-byte boundaries for better performance
        if self.current_local_offset % 2 != 0:
            self.current_local_offset -= 1
            
        self.current_local_offset -= size
        self.variables[name] = self.current_local_offset
        self.max_locals_size = max(self.max_locals_size, abs(self.current_local_offset))
        logger.debug(f"Local variable {name} at FP{self.current_local_offset}")
        return self.current_local_offset
        
    def get_variable_location(self, name: str) -> Tuple[str, int]:
        """Get the stack location for a variable."""
        if name in self.parameters:
            offset = self.parameters[name]
            return 'param', offset
        elif name in self.variables:
            offset = self.variables[name]
            return 'local', offset
        else:
            raise ValueError(f"Unknown variable: {name}")


class PureStackCodeGenerator:
    """Pure stack-centric code generator - minimizes register usage."""

    def __init__(self):
        self.label_counter = 0
        self.current_function = None
        self.stack_frames = {}      # function_name -> StackFrame
        self.string_constants = {}  # string_value -> label_name
        self.string_counter = 0
        self._constant_values = {}  # Track constant values for optimization
        
        # Built-in function handlers
        self.graphics_builtins = GraphicsBuiltins()
        self.sound_builtins = SoundBuiltins()
        self.string_builtins = StringBuiltins()
        self.system_builtins = SystemBuiltins()
        
        # Reserve minimal registers for computation only
        self.computation_regs = ['R0', 'R1']  # Only for immediate calculations
        self.address_regs = ['P0', 'P1']      # Only for address calculations (P8=SP, P9=FP reserved)
        
    def generate(self, ir_module: IRModule) -> str:
        """Generate pure stack-centric assembly code."""
        logger.info("Starting pure stack-centric code generation")
        
        output = []
        output.extend([
            "; Generated by Astrid Pure Stack-Centric Compiler",
            "; Architecture: Nova-16 with pure stack-first approach", 
            "; Variables stored on stack, minimal register usage",
            "; Stack Layout: [locals][FP][return_addr][params]",
            ""
        ])
        
        # Pre-analyze all functions to build stack frames
        for function in ir_module.functions:
            self._analyze_function_stack_layout(function)
        
        # Generate code for each function
        for function in ir_module.functions:
            self.current_function = function.name
            function_code = self._generate_function(function)
            output.extend(function_code)
            output.append("")
        
        # Generate string constants data section if any were used
        if self.string_constants:
            output.extend([
                "; String constants data section",
                ""
            ])
            for string_value, label in self.string_constants.items():
                # Escape string for assembler output
                escaped_string = self._escape_string_for_assembly(string_value)
                # Use Nova-16 DEFSTR directive which automatically null-terminates
                output.append(f"{label}: DEFSTR \"{escaped_string}\"")
            output.append("")
        
        return "\n".join(output)
    
    def _analyze_function_stack_layout(self, function: IRFunction):
        """Analyze function to determine pure stack layout."""
        stack_frame = StackFrame(function.name)
        self.stack_frames[function.name] = stack_frame
        
        # Add parameters to stack frame
        if hasattr(function, 'parameter_ir_vars'):
            for i, param_var in enumerate(function.parameter_ir_vars):
                stack_frame.add_parameter(param_var, i)
        
        # Collect all local variables from IR
        local_vars = set()
        for block in function.blocks:
            for instr in block.instructions:
                # Result variables are locals
                if hasattr(instr, 'result') and instr.result and instr.result.startswith('v'):
                    local_vars.add(instr.result)
                # Operand variables that aren't parameters are locals  
                if hasattr(instr, 'operands'):
                    for operand in instr.operands:
                        if isinstance(operand, str) and operand.startswith('v'):
                            if operand not in stack_frame.parameters:
                                local_vars.add(operand)
        
        # Add all local variables to stack frame
        for var in sorted(local_vars):  # Sort for consistent layout
            if var not in stack_frame.parameters:
                stack_frame.add_local_variable(var)
    
    def _generate_function(self, function: IRFunction) -> List[str]:
        """Generate pure stack-centric function code."""
        code = []
        stack_frame = self.stack_frames[function.name]
        
        # Initialize constant value tracking for this function
        self._constant_values = {}
        
        # Function label
        code.append(f"{function.name}:")
        
        # Function prologue (stack setup)
        if function.name == "main":
            # Initialize stack pointer and frame pointer for main function
            code.extend([
                "    MOV SP, 0xF000                ; Initialize stack pointer to safe area",
                "    MOV FP, SP                    ; Initialize frame pointer for main"
            ])
        else:
            code.extend([
                "    PUSH FP                       ; Save caller's frame pointer",
                "    MOV FP, SP                    ; Set new frame pointer"
            ])
        
        # Allocate stack space for local variables
        if stack_frame.max_locals_size > 0:
            code.append(f"    SUB SP, {stack_frame.max_locals_size}      ; Allocate {stack_frame.max_locals_size} bytes for locals")
        
        # Generate code for each basic block in execution order
        ordered_blocks = self._order_blocks_for_execution(function.blocks)
        
        for block in ordered_blocks:
            if block.name != "entry":
                code.append(f"{block.name}:")
            
            for instr in block.instructions:
                instr_code = self._generate_instruction(instr, stack_frame)
                code.extend(instr_code)
            
            # Check if this block should terminate the function
            if function.name == "main" and self._should_terminate_function(block, function):
                code.extend([
                    "    ; Main function completed - force halt",
                    "    MOV SP, FP                    ; Restore stack pointer", 
                    "    HLT                           ; Halt system"
                ])
        
        # Add implicit termination for main function if no explicit return/halt
        if function.name == "main":
            # Check if the last instruction is already a halt or return
            has_termination = False
            if function.blocks:
                last_block = function.blocks[-1]
                if last_block.instructions:
                    last_instr = last_block.instructions[-1]
                    if (hasattr(last_instr, 'op') and 
                        (last_instr.op in ['halt', 'ret', 'return'] or
                         (last_instr.op == 'call' and len(last_instr.operands) > 0 and last_instr.operands[0] == 'halt'))):
                        has_termination = True
            
            if not has_termination:
                code.extend([
                    "    ; Halt processor",
                    "    MOV SP, FP                    ; Restore stack pointer",
                    "    HLT                           ; Halt system"
                ])
        else:
            # Add implicit return for non-main functions if no explicit return
            has_return = False
            if function.blocks:
                last_block = function.blocks[-1]
                if last_block.instructions:
                    last_instr = last_block.instructions[-1]
                    if (hasattr(last_instr, 'op') and last_instr.op in ['ret', 'return']):
                        has_return = True
            
            if not has_return:
                code.extend([
                    "    ; Implicit return for void function",
                    "    MOV SP, FP                    ; Restore stack pointer",
                    "    POP FP                        ; Restore caller's frame pointer",
                    "    RET                           ; Return to caller"
                ])
        
        return code
    
    def _generate_instruction(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate stack-centric instruction code."""
        op = instr.opcode.lower()
        
        if op == 'assign':
            return self._generate_stack_assign(instr, stack_frame)
        elif op in ['+', '-', '*', '/', '%']:
            return self._generate_stack_arithmetic(instr, stack_frame, op)
        elif op in ['&', '|', '^', '~', '<<', '>>']:
            return self._generate_stack_bitwise(instr, stack_frame, op)
        elif op == 'const':
            return self._generate_stack_const(instr, stack_frame)
        elif op == 'call':
            return self._generate_stack_call(instr, stack_frame)
        elif op == 'return':
            return self._generate_stack_return(instr, stack_frame)
        elif op == 'compare':
            return self._generate_stack_compare(instr, stack_frame)
        elif op == 'branch':
            return self._generate_stack_branch(instr, stack_frame)
        elif op == 'jmp':
            return self._generate_stack_jump(instr, stack_frame)
        elif op in ['<=', '<', '>', '>=', '==', '!=']:
            return self._generate_stack_comparison(instr, stack_frame, op)
        elif op == 'br':
            return self._generate_stack_branch_conditional(instr, stack_frame)
        elif op in ['u++', '++', 'u--', '--']:
            return self._generate_stack_increment(instr, stack_frame, op)
        elif op == 'array_set':
            return self._generate_stack_array_set(instr, stack_frame)
        elif op == 'array_get':
            return self._generate_stack_array_get(instr, stack_frame)
        else:
            logger.warning(f"Unimplemented instruction: {op}")
            return [f"    ; TODO: Implement {op}"]
    
    def _generate_stack_const(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate constant assignment using pure stack operations."""
        code = []
        const_value = instr.operands[0] if instr.operands else 0
        dest_var = instr.result
        
        if not dest_var:
            return ["    ; Invalid const - no destination"]
        
        # Track this constant value for optimization
        self._constant_values[dest_var] = const_value
        
        # Get stack location for destination
        location_type, offset = stack_frame.get_variable_location(dest_var)
        
        # Handle string constants differently
        # Check for strings: either has spaces or is a non-numeric string
        if isinstance(const_value, str) and (
            ' ' in const_value or  # String with spaces (like "De Nova Stella" without quotes)
            not (const_value.isdigit() or const_value.lstrip('-').isdigit())
        ):
            # This is a string constant
            logger.info(f"Processing string constant: '{const_value}'")
            string_label = self._get_string_constant_label(const_value)
            
            if location_type == 'local':
                code.extend([
                    f"    MOV P1, {string_label}        ; Load string address '{const_value}'",
                    self._generate_direct_indexed_access('FP', offset, 'MOV', 'P1')
                ])
            elif location_type == 'param':
                code.extend([
                    f"    MOV P1, {string_label}        ; Load string address '{const_value}'",
                    self._generate_direct_indexed_access('FP', offset, 'MOV', 'P1')
                ])
        else:
            # Regular numeric constant
            if location_type == 'local':
                # Store to local variable using direct indexed addressing
                # Always use 16-bit operations for variables to maintain consistency
                code.extend([
                    f"    MOV P1, {const_value}         ; Load constant {const_value}",
                    self._generate_direct_indexed_access('FP', offset, 'MOV', 'P1')
                ])
            elif location_type == 'param':
                # Store to parameter using direct indexed addressing
                # Always use 16-bit operations for variables to maintain consistency
                code.extend([
                    f"    MOV P1, {const_value}         ; Load constant {const_value}",
                    self._generate_direct_indexed_access('FP', offset, 'MOV', 'P1')
                ])
        
        return code
    
    def _get_string_constant_label(self, string_value: str) -> str:
        """Get or create a label for a string constant."""
        if string_value in self.string_constants:
            return self.string_constants[string_value]
        
        # Create new string label
        self.string_counter += 1
        label = f"str_{self.string_counter}"
        self.string_constants[string_value] = label
        return label
    
    def _generate_stack_assign(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate assignment using pure stack operations."""
        code = []
        
        if not instr.operands or not instr.result:
            return ["    ; Invalid assignment"]
        
        source = instr.operands[0]
        dest_var = instr.result
        
        # Get destination location
        dest_type, dest_offset = stack_frame.get_variable_location(dest_var)
        
        # Handle different source types
        if isinstance(source, int):
            # Constant source - use direct indexed addressing
            if source <= 255:
                code.extend([
                    f"    MOV R0, {source}              ; Load constant {source}",
                    self._generate_direct_indexed_access('FP', dest_offset, 'MOV', 'R0')
                ])
            else:
                code.extend([
                    f"    MOV P1, {source}         ; Load 16-bit constant {source}",
                    self._generate_direct_indexed_access('FP', dest_offset, 'MOV', 'P1')
                ])
        elif isinstance(source, str) and source.startswith('v'):
            # Variable source - direct indexed stack-to-stack copy
            source_type, source_offset = stack_frame.get_variable_location(source)
            
            # Use direct indexed addressing for both source and destination
            if source_offset == 0:
                source_addr = "[FP]"
            elif source_offset > 0:
                source_addr = f"[FP+{source_offset}]"
            else:
                source_addr = f"[FP{source_offset}]"
                
            code.extend([
                f"    MOV P2, {source_addr}             ; Load from {source} (16-bit)",
                self._generate_direct_indexed_access('FP', dest_offset, 'MOV', 'P2')
            ])
        elif isinstance(source, str):
            # String literal source - convert to label and store pointer
            string_label = self._get_string_constant_label(source)
            code.extend([
                f"    MOV P1, {string_label}        ; Load string address '{source}'",
                self._generate_direct_indexed_access('FP', dest_offset, 'MOV', 'P1')
            ])
        
        return code
    
    def _generate_stack_arithmetic(self, instr: IRInstruction, stack_frame: StackFrame, op: str) -> List[str]:
        """Generate arithmetic using pure stack operations."""
        code = []
        
        if len(instr.operands) < 2 or not instr.result:
            return [f"    ; Invalid {op} operation"]
        
        left_operand = instr.operands[0]
        right_operand = instr.operands[1]
        result_var = instr.result
        
        # Map operation to assembly instruction
        asm_op_map = {'+': 'ADD', '-': 'SUB', '*': 'MUL', '/': 'DIV', '%': 'MOD'}
        asm_op = asm_op_map.get(op, 'ADD')
        
        # Load left operand into R0
        if isinstance(left_operand, int):
            code.append(f"    MOV R0, {left_operand}        ; Load left constant")
        elif isinstance(left_operand, str) and left_operand.startswith('v'):
            left_type, left_offset = stack_frame.get_variable_location(left_operand)
            if left_offset == 0:
                left_addr = "[FP]"
            elif left_offset > 0:
                left_addr = f"[FP+{left_offset}]"
            else:
                left_addr = f"[FP{left_offset}]"
            code.append(f"    MOV R0, {left_addr}           ; Load left operand {left_operand}")
        
        # Perform operation with right operand
        if isinstance(right_operand, int):
            code.append(f"    {asm_op} R0, {right_operand}  ; {op} right constant")
        elif isinstance(right_operand, str) and right_operand.startswith('v'):
            right_type, right_offset = stack_frame.get_variable_location(right_operand)
            if right_offset == 0:
                right_addr = "[FP]"
            elif right_offset > 0:
                right_addr = f"[FP+{right_offset}]"
            else:
                right_addr = f"[FP{right_offset}]"
            code.extend([
                f"    MOV R1, {right_addr}          ; Load right operand {right_operand}",
                f"    {asm_op} R0, R1               ; {op} operands"
            ])
        
        # Store result back to stack using direct indexed addressing
        result_type, result_offset = stack_frame.get_variable_location(result_var)
        code.append(self._generate_direct_indexed_access('FP', result_offset, 'MOV', 'R0'))
        
        return code
    
    def _generate_stack_bitwise(self, instr: IRInstruction, stack_frame: StackFrame, op: str) -> List[str]:
        """Generate bitwise operations using pure stack operations."""
        code = []
        
        if len(instr.operands) < 2 or not instr.result:
            return [f"    ; Invalid {op} operation"]
        
        left_operand = instr.operands[0]
        right_operand = instr.operands[1]
        result_var = instr.result
        
        # Map operation to assembly instruction
        asm_op_map = {'&': 'AND', '|': 'OR', '^': 'XOR', '~': 'NOT', '<<': 'SHL', '>>': 'SHR'}
        asm_op = asm_op_map.get(op, 'AND')
        
        # Load left operand into R0
        if isinstance(left_operand, int):
            code.append(f"    MOV R0, {left_operand}        ; Load left constant")
        elif isinstance(left_operand, str) and left_operand.startswith('v'):
            left_type, left_offset = stack_frame.get_variable_location(left_operand)
            if left_offset == 0:
                left_addr = "[FP]"
            elif left_offset > 0:
                left_addr = f"[FP+{left_offset}]"
            else:
                left_addr = f"[FP{left_offset}]"
            code.append(f"    MOV R0, {left_addr}           ; Load left operand {left_operand}")
        
        # Handle unary NOT operation and shift operations
        if op == '~':
            code.append(f"    {asm_op} R0                   ; Bitwise NOT")
        elif op in ['<<', '>>']:
            # Shift operations: shift left/right by right operand amount
            if isinstance(right_operand, int):
                # Nova-16 shift instructions only take register operands, so load constant first
                if right_operand == 1:
                    code.append(f"    {asm_op} R0                   ; {op} by 1")
                else:
                    # Multiple shifts for larger amounts
                    for _ in range(min(right_operand, 8)):  # Limit to prevent infinite shifts
                        code.append(f"    {asm_op} R0                   ; {op} by 1")
            elif isinstance(right_operand, str) and right_operand.startswith('v'):
                # Variable shift amount - need to implement with loop
                code.append(f"    ; TODO: Variable shift amount not yet implemented")
        else:
            # Perform operation with right operand
            if isinstance(right_operand, int):
                code.append(f"    {asm_op} R0, {right_operand}  ; {op} right constant")
            elif isinstance(right_operand, str) and right_operand.startswith('v'):
                right_type, right_offset = stack_frame.get_variable_location(right_operand)
                if right_offset == 0:
                    right_addr = "[FP]"
                elif right_offset > 0:
                    right_addr = f"[FP+{right_offset}]"
                else:
                    right_addr = f"[FP{right_offset}]"
                code.extend([
                    f"    MOV R1, {right_addr}          ; Load right operand {right_operand}",
                    f"    {asm_op} R0, R1               ; {op} operands"
                ])
        
        # Store result back to stack using direct indexed addressing
        result_type, result_offset = stack_frame.get_variable_location(result_var)
        code.append(self._generate_direct_indexed_access('FP', result_offset, 'MOV', 'R0'))
        
        return code

    def _generate_stack_call(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate function call using pure stack parameter passing."""
        code = []
        
        if not instr.operands:
            return ["    ; Invalid call - no function name"]
        
        function_name = instr.operands[0]
        parameters = instr.operands[1:] if len(instr.operands) > 1 else []
        
        # Handle special built-in functions first
        if function_name == 'halt':
            return ["    HLT                           ; Halt system"]
        
        # Check for graphics builtin functions
        graphics_func = self.graphics_builtins.get_function(function_name)
        if graphics_func:
            # Resolve parameters to actual values for optimization
            resolved_params = []
            for param in parameters:
                if isinstance(param, str) and param.startswith('v'):
                    # Check if this is a constant variable we can resolve
                    if param in self._constant_values:
                        resolved_params.append(self._constant_values[param])
                    else:
                        resolved_params.append(param)
                else:
                    resolved_params.append(param)
            return self._generate_builtin_graphics_call(function_name, resolved_params, stack_frame, instr.result)
        
        # Check for string builtin functions
        string_func = self.string_builtins.get_function(function_name)
        if string_func:
            # Resolve parameters for string functions too
            resolved_params = []
            for param in parameters:
                if isinstance(param, str) and param.startswith('v'):
                    if param in self._constant_values:
                        resolved_params.append(self._constant_values[param])
                    else:
                        resolved_params.append(param)
                else:
                    resolved_params.append(param)
            return self._generate_builtin_string_call(function_name, resolved_params, stack_frame, instr.result)
        
        # Check for sound builtin functions  
        sound_func = self.sound_builtins.get_function(function_name)
        if sound_func:
            return self._generate_builtin_sound_call(function_name, parameters, stack_frame, instr.result)
        
        # Check for system builtin functions
        system_func = self.system_builtins.get_function(function_name)
        if system_func:
            return self._generate_builtin_system_call(function_name, parameters, stack_frame, instr.result)
        
        # Regular user-defined function call
        # Push parameters in reverse order (right-to-left)
        for param in reversed(parameters):
            if isinstance(param, int):
                code.append(f"    PUSH {param}                  ; Push constant parameter")
            elif isinstance(param, str) and param.startswith('v'):
                param_type, param_offset = stack_frame.get_variable_location(param)
                if param_offset == 0:
                    param_addr = "[FP]"
                elif param_offset > 0:
                    param_addr = f"[FP+{param_offset}]"
                else:
                    param_addr = f"[FP{param_offset}]"
                code.extend([
                    f"    MOV R0, {param_addr}          ; Load parameter {param}",
                    f"    PUSH R0                       ; Push parameter to stack"
                ])
        
        # Call the function
        code.append(f"    CALL {function_name}          ; Call function")
        
        # Clean up parameters
        if parameters:
            param_bytes = len(parameters) * 2  # 2 bytes per parameter
            code.append(f"    ADD SP, {param_bytes}         ; Clean up {len(parameters)} parameters")
        
        # Store return value if needed
        if instr.result and instr.result.startswith('v'):
            result_type, result_offset = stack_frame.get_variable_location(instr.result)
            code.append(self._generate_direct_indexed_access('FP', result_offset, 'MOV', 'R0'))
        
        return code
    
    def _generate_stack_return(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate return using pure stack operations."""
        code = []
        
        # Load return value if provided
        if instr.operands:
            return_value = instr.operands[0]
            if isinstance(return_value, int):
                code.append(f"    MOV R0, {return_value}        ; Load return constant")
            elif isinstance(return_value, str) and return_value.startswith('v'):
                ret_type, ret_offset = stack_frame.get_variable_location(return_value)
                if ret_offset == 0:
                    ret_addr = "[FP]"
                elif ret_offset > 0:
                    ret_addr = f"[FP+{ret_offset}]"
                else:
                    ret_addr = f"[FP{ret_offset}]"
                code.append(f"    MOV R0, {ret_addr}            ; Load return value {return_value}")
        
        # Function epilogue
        if self.current_function != "main":
            code.extend([
                f"    MOV SP, FP                    ; Restore stack pointer",
                f"    POP FP                        ; Restore caller's frame pointer",
                f"    RET                           ; Return to caller"
            ])
        
        return code
    
    def _generate_stack_compare(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate comparison using pure stack operations."""
        code = []
        
        if len(instr.operands) < 2:
            return ["    ; Invalid compare - need 2 operands"]
        
        left_operand = instr.operands[0]
        right_operand = instr.operands[1]
        
        # Check if we need 16-bit operations
        # Use 16-bit if any immediate constant > 255, or if we're comparing variables that might contain large values
        needs_16bit = False
        if isinstance(left_operand, int) and left_operand > 255:
            needs_16bit = True
        if isinstance(right_operand, int) and right_operand > 255:
            needs_16bit = True
        
        # Special handling: if comparing variable with 256, use 16-bit approach
        if (isinstance(left_operand, str) and isinstance(right_operand, int) and right_operand == 256) or \
           (isinstance(right_operand, str) and isinstance(left_operand, int) and left_operand == 256):
            needs_16bit = True
        
        # Load left operand
        if isinstance(left_operand, int):
            if needs_16bit:
                code.append(f"    MOV P0, {left_operand}        ; Load left 16-bit constant")
            else:
                code.append(f"    MOV R0, {left_operand}        ; Load left constant")
        elif isinstance(left_operand, str) and left_operand.startswith('v'):
            left_type, left_offset = stack_frame.get_variable_location(left_operand)
            if left_offset == 0:
                left_addr = "[FP]"
            elif left_offset > 0:
                left_addr = f"[FP+{left_offset}]"
            else:
                left_addr = f"[FP{left_offset}]"
            if needs_16bit:
                code.append(f"    MOV P0, {left_addr}           ; Load left operand {left_operand} as 16-bit")
            else:
                code.append(f"    MOV R0, {left_addr}           ; Load left operand {left_operand}")
        
        # Compare with right operand
        if isinstance(right_operand, int):
            if needs_16bit:
                code.append(f"    CMP P0, {right_operand}       ; Compare 16-bit with constant")
            else:
                code.append(f"    CMP R0, {right_operand}       ; Compare with constant")
        elif isinstance(right_operand, str) and right_operand.startswith('v'):
            right_type, right_offset = stack_frame.get_variable_location(right_operand)
            if right_offset == 0:
                right_addr = "[FP]"
            elif right_offset > 0:
                right_addr = f"[FP+{right_offset}]"
            else:
                right_addr = f"[FP{right_offset}]"
            if needs_16bit:
                code.extend([
                    f"    MOV P1, {right_addr}          ; Load right operand {right_operand} as 16-bit",
                    f"    CMP P0, P1                    ; Compare 16-bit operands"
                ])
            else:
                code.extend([
                    f"    MOV R1, {right_addr}          ; Load right operand {right_operand}",
                    f"    CMP R0, R1                    ; Compare operands"
                ])
        
        return code
    
    def _generate_stack_branch(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate branch instruction."""
        code = []
        
        if not instr.operands:
            return ["    ; Invalid branch - no target"]
        
        target = instr.operands[0]
        
        # Handle conditional branches
        if hasattr(instr, 'condition'):
            condition = instr.condition
            branch_map = {
                'eq': 'JZ', 'ne': 'JNZ', 'lt': 'JLT', 
                'le': 'JLE', 'gt': 'JGT', 'ge': 'JGE'
            }
            branch_instr = branch_map.get(condition, 'JMP')
            code.append(f"    {branch_instr} {target}       ; Conditional branch")
        else:
            code.append(f"    JMP {target}                  ; Unconditional branch")
        
        return code
    
    def _generate_direct_indexed_access(self, base_reg: str, offset: int, operation: str, operand: str = None) -> str:
        """Generate direct indexed memory access according to Nova-16 syntax standards."""
        if offset == 0:
            indexed_addr = f"[{base_reg}]"
        elif offset > 0:
            indexed_addr = f"[{base_reg}+{offset}]"
        else:
            indexed_addr = f"[{base_reg}{offset}]"  # offset already negative
            
        if operand:
            return f"    {operation} {indexed_addr}, {operand}      ; Direct indexed access"
        else:
            return f"    {operation} {indexed_addr}               ; Direct indexed access"
    
    def _generate_address_calculation(self, register: str, base_reg: str, offset: int) -> List[str]:
        """DEPRECATED: Use direct indexed addressing instead. This method should not be called.
        
        The Nova-16 architecture supports direct indexed addressing like [FP+4] and [SP-2],
        which should be used instead of multi-instruction address calculations.
        
        See STACK_ADDRESSING_SYNTAX.md for proper syntax patterns.
        """
        # Return empty list - all callers should use _generate_direct_indexed_access instead
        logger.warning(f"Deprecated _generate_address_calculation called with {register}, {base_reg}, {offset}")
        return []
    
    def _get_unique_label(self, prefix: str = "label") -> str:
        """Generate unique labels."""
        self.label_counter += 1
        return f"{prefix}_{self.label_counter}"

    def _generate_stack_jump(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate unconditional jump instruction."""
        if not instr.operands:
            return ["    ; Invalid jump - no target"]
        
        target = instr.operands[0]
        return [f"    JMP {target}                  ; Unconditional jump"]

    def _generate_stack_comparison(self, instr: IRInstruction, stack_frame: StackFrame, op: str) -> List[str]:
        """Generate comparison instructions (<, <=, >, >=, ==, !=)."""
        code = []
        
        if len(instr.operands) < 2:
            return ["    ; Invalid comparison - need 2 operands"]
        
        left_operand = instr.operands[0]
        right_operand = instr.operands[1]
        result_var = instr.result
        
        # Determine if we need 16-bit comparison
        needs_16bit = False
        if isinstance(right_operand, int) and right_operand > 255:
            needs_16bit = True
        if isinstance(left_operand, int) and left_operand > 255:
            needs_16bit = True
        
        # Special detection: if comparing with variable that stores 256
        # This is a heuristic for the specific case of for loops with 256 limit
        if isinstance(right_operand, str) and right_operand.startswith('v') and \
           isinstance(left_operand, str) and left_operand.startswith('v'):
            # If this might be a loop comparison (common pattern), use 16-bit to be safe
            needs_16bit = True
        
        # Load left operand
        if isinstance(left_operand, int):
            if needs_16bit:
                code.append(f"    MOV P0, {left_operand}        ; Load left 16-bit constant")
            else:
                code.append(f"    MOV R0, {left_operand}        ; Load left constant")
        elif isinstance(left_operand, str) and left_operand.startswith('v'):
            left_type, left_offset = stack_frame.get_variable_location(left_operand)
            # Use direct indexed addressing instead of deprecated address calculation
            if left_offset == 0:
                left_addr = "[FP]"
            elif left_offset > 0:
                left_addr = f"[FP+{left_offset}]"
            else:
                left_addr = f"[FP{left_offset}]"
                
            if needs_16bit:
                code.append(f"    MOV P0, {left_addr}          ; Load left operand {left_operand} as 16-bit")
            else:
                code.append(f"    MOV R0, {left_addr}          ; Load left operand {left_operand}")
        
        # Load right operand and compare
        if isinstance(right_operand, int):
            if needs_16bit:
                code.append(f"    CMP P0, {right_operand}       ; Compare 16-bit values")
            else:
                code.append(f"    CMP R0, {right_operand}       ; Compare with 8-bit constant")
        elif isinstance(right_operand, str) and right_operand.startswith('v'):
            right_type, right_offset = stack_frame.get_variable_location(right_operand)
            # Use direct indexed addressing instead of deprecated address calculation
            if right_offset == 0:
                right_addr = "[FP]"
            elif right_offset > 0:
                right_addr = f"[FP+{right_offset}]"
            else:
                right_addr = f"[FP{right_offset}]"
                
            if needs_16bit:
                code.extend([
                    f"    MOV P1, {right_addr}          ; Load right operand {right_operand} as 16-bit",
                    f"    CMP P0, P1                    ; Compare 16-bit operands"
                ])
            else:
                code.extend([
                    f"    MOV R1, {right_addr}          ; Load right operand {right_operand}",
                    f"    CMP R0, R1                    ; Compare operands"
                ])
        
        # Set result based on comparison
        result_label_true = self._get_unique_label("cmp_true")
        result_label_end = self._get_unique_label("cmp_end")
        
        # Map comparison operators to jump instructions
        jump_map = {
            '<': 'JLT', '<=': 'JLE', '>': 'JGT', 
            '>=': 'JGE', '==': 'JZ', '!=': 'JNZ'
        }
        
        jump_instr = jump_map.get(op, 'JZ')
        
        code.extend([
            f"    {jump_instr} {result_label_true}     ; Jump if condition true",
            f"    MOV R0, 0                     ; Set false result",
            f"    JMP {result_label_end}        ; Skip true case",
            f"{result_label_true}:",
            f"    MOV R0, 1                     ; Set true result",
            f"{result_label_end}:"
        ])
        
        # Store result if there's a destination
        if result_var:
            result_type, result_offset = stack_frame.get_variable_location(result_var)
            code.append(self._generate_direct_indexed_access('FP', result_offset, 'MOV', 'R0'))
        
        return code

    def _generate_stack_branch_conditional(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate conditional branch instruction."""
        code = []
        
        if len(instr.operands) < 3:
            return ["    ; Invalid br - need condition and 2 targets"]
        
        condition_var = instr.operands[0]
        true_target = instr.operands[1] 
        false_target = instr.operands[2]
        
        # Load condition variable
        if isinstance(condition_var, str) and condition_var.startswith('v'):
            cond_type, cond_offset = stack_frame.get_variable_location(condition_var)
            if cond_offset == 0:
                cond_addr = "[FP]"
            elif cond_offset > 0:
                cond_addr = f"[FP+{cond_offset}]"
            else:
                cond_addr = f"[FP{cond_offset}]"
            code.extend([
                f"    MOV R0, {cond_addr}           ; Load condition {condition_var}",
                f"    CMP R0, 0                     ; Test condition",
                f"    JNZ {true_target}             ; Jump to true branch if non-zero",
                f"    JMP {false_target}            ; Jump to false branch"
            ])
        else:
            code.extend([
                f"    MOV R0, {condition_var}       ; Load condition constant",
                f"    CMP R0, 0                     ; Test condition",
                f"    JNZ {true_target}             ; Jump to true branch if non-zero",
                f"    JMP {false_target}            ; Jump to false branch"
            ])
        
        return code

    def _generate_stack_increment(self, instr: IRInstruction, stack_frame: StackFrame, op: str) -> List[str]:
        """Generate increment/decrement instructions (++, --, u++, u--)."""
        code = []
        
        if not instr.operands:
            return ["    ; Invalid increment - no operand"]
        
        var_name = instr.operands[0]
        result_var = instr.result or var_name
        
        # Check if we need 16-bit operations for variables that might exceed 255
        # For loop variables and int16 types, use 16-bit operations
        needs_16bit = True  # Conservative: use 16-bit for all increments to be safe
        
        # Load current value
        if isinstance(var_name, str) and var_name.startswith('v'):
            var_type, var_offset = stack_frame.get_variable_location(var_name)
            if var_offset == 0:
                var_addr = "[FP]"
            elif var_offset > 0:
                var_addr = f"[FP+{var_offset}]"
            else:
                var_addr = f"[FP{var_offset}]"
            
            if needs_16bit:
                code.append(f"    MOV P1, {var_addr}            ; Load current 16-bit value of {var_name}")
                
                # Apply increment/decrement
                if op in ['++', 'u++']:
                    code.append(f"    ADD P1, 1                     ; Increment 16-bit")
                elif op in ['--', 'u--']:
                    code.append(f"    SUB P1, 1                     ; Decrement 16-bit")
                
                # Store result back using direct indexed addressing
                code.append(self._generate_direct_indexed_access('FP', var_offset, 'MOV', 'P1'))
            else:
                code.append(f"    MOV R0, {var_addr}            ; Load current value of {var_name}")
                
                # Apply increment/decrement
                if op in ['++', 'u++']:
                    code.append(f"    ADD R0, 1                     ; Increment")
                elif op in ['--', 'u--']:
                    code.append(f"    SUB R0, 1                     ; Decrement")
                
                # Store result back using direct indexed addressing
                code.append(self._generate_direct_indexed_access('FP', var_offset, 'MOV', 'R0'))
        
        return code

    def _generate_builtin_graphics_call(self, function_name: str, parameters: List, stack_frame: StackFrame, result_var: str = None) -> List[str]:
        """Generate code for builtin graphics function calls."""
        code = []
        
        # Load parameters into the correct registers/positions for graphics functions
        if function_name == 'set_pixel':
            if len(parameters) >= 3:
                # set_pixel(x, y, color) - optimize for direct constants
                x_param, y_param, color_param = parameters[0], parameters[1], parameters[2]
                
                # Handle X parameter - prefer direct loading for constants
                if isinstance(x_param, int):
                    code.append(f"    MOV VX, {x_param}             ; Set X coordinate")
                elif isinstance(x_param, str) and x_param.startswith('v'):
                    x_type, x_offset = stack_frame.get_variable_location(x_param)
                    if x_offset == 0:
                        x_addr = "[FP]"
                    elif x_offset > 0:
                        x_addr = f"[FP+{x_offset}]"
                    else:
                        x_addr = f"[FP{x_offset}]"
                    code.extend([
                        f"    MOV R0, {x_addr}              ; Load X from {x_param}",
                        f"    MOV VX, R0                    ; Set X coordinate"
                    ])
                
                # Handle Y parameter - prefer direct loading for constants
                if isinstance(y_param, int):
                    code.append(f"    MOV VY, {y_param}             ; Set Y coordinate")
                elif isinstance(y_param, str) and y_param.startswith('v'):
                    y_type, y_offset = stack_frame.get_variable_location(y_param)
                    if y_offset == 0:
                        y_addr = "[FP]"
                    elif y_offset > 0:
                        y_addr = f"[FP+{y_offset}]"
                    else:
                        y_addr = f"[FP{y_offset}]"
                    code.extend([
                        f"    MOV R0, {y_addr}              ; Load Y from {y_param}",
                        f"    MOV VY, R0                    ; Set Y coordinate"
                    ])
                
                # Handle color parameter - prefer direct loading for constants
                if isinstance(color_param, int):
                    code.extend([
                        f"    MOV R0, {color_param}         ; Load color constant",
                        f"    MOV VM, 0                     ; Set coordinate mode",
                        f"    SWRITE R0                     ; Write pixel"
                    ])
                elif isinstance(color_param, str) and color_param.startswith('v'):
                    color_type, color_offset = stack_frame.get_variable_location(color_param)
                    if color_offset == 0:
                        color_addr = "[FP]"
                    elif color_offset > 0:
                        color_addr = f"[FP+{color_offset}]"
                    else:
                        color_addr = f"[FP{color_offset}]"
                    code.extend([
                        f"    MOV R0, {color_addr}          ; Load color from {color_param}",
                        f"    MOV VM, 0                     ; Set coordinate mode",
                        f"    SWRITE R0                     ; Write pixel"
                    ])
                else:
                    # Fallback for when color is loaded but no direct register access
                    code.extend([
                        f"    MOV VM, 0                     ; Set coordinate mode",
                        f"    SWRITE R8                     ; Write pixel"
                    ])
        
        elif function_name == 'set_layer':
            if len(parameters) >= 1:
                layer_param = parameters[0]
                
                # Load layer parameter into VL
                if isinstance(layer_param, int):
                    code.append(f"    MOV VL, {layer_param}         ; Set active layer")
                elif isinstance(layer_param, str) and layer_param.startswith('v'):
                    layer_type, layer_offset = stack_frame.get_variable_location(layer_param)
                    if layer_offset == 0:
                        layer_addr = "[FP]"
                    elif layer_offset > 0:
                        layer_addr = f"[FP+{layer_offset}]"
                    else:
                        layer_addr = f"[FP{layer_offset}]"
                    code.extend([
                        f"    MOV R0, {layer_addr}          ; Load layer from {layer_param}",
                        f"    MOV VL, R0                    ; Set active layer"
                    ])
        
        elif function_name == 'roll_screen_x':
            if len(parameters) >= 1:
                amount_param = parameters[0]
                
                # Load amount parameter
                if isinstance(amount_param, int):
                    code.append(f"    MOV R0, {amount_param}        ; Set roll amount")
                elif isinstance(amount_param, str) and amount_param.startswith('v'):
                    amount_type, amount_offset = stack_frame.get_variable_location(amount_param)
                    if amount_offset == 0:
                        amount_addr = "[FP]"
                    elif amount_offset > 0:
                        amount_addr = f"[FP+{amount_offset}]"
                    else:
                        amount_addr = f"[FP{amount_offset}]"
                    code.append(f"    MOV R0, {amount_addr}         ; Load roll amount from {amount_param}")
                
                code.append(f"    SROLX R0                      ; Roll screen horizontally")
        
        else:
            # Generic builtin function call (fallback)
            code.append(f"    ; TODO: Implement graphics function {function_name}")
        
        # Store return value if needed
        if result_var and result_var.startswith('v'):
            result_type, result_offset = stack_frame.get_variable_location(result_var)
            code.append(self._generate_direct_indexed_access('FP', result_offset, 'MOV', 'R0'))
        
        return code
    
    def _generate_builtin_string_call(self, function_name: str, parameters: List, stack_frame: StackFrame, result_var: str = None) -> List[str]:
        """Generate code for builtin string function calls."""
        code = []
        
        if function_name == 'print_string':
            if len(parameters) >= 4:
                # print_string(string_ptr, x, y, color)
                string_param, x_param, y_param, color_param = parameters[0], parameters[1], parameters[2], parameters[3]
                
                # Load string parameter into P0
                if isinstance(string_param, str) and string_param.startswith('v'):
                    string_type, string_offset = stack_frame.get_variable_location(string_param)
                    if string_offset == 0:
                        string_addr = "[FP]"
                    elif string_offset > 0:
                        string_addr = f"[FP+{string_offset}]"
                    else:
                        string_addr = f"[FP{string_offset}]"
                    code.extend([
                        f"    MOV P0, {string_addr}         ; Load string pointer from {string_param}",
                        f"    ; String pointer now in P0 (16-bit)"
                    ])
                else:
                    # Handle string constant - convert literal to label reference
                    if isinstance(string_param, str) and not string_param.startswith('str_'):
                        # This is a literal string, convert to label
                        string_label = self._get_string_constant_label(string_param)
                        code.append(f"    MOV P0, {string_label}        ; Load string pointer")
                    else:
                        # Already a label reference
                        code.append(f"    MOV P0, {string_param}        ; Load string pointer")
                
                # Load x parameter into VX
                if isinstance(x_param, int):
                    code.append(f"    MOV VX, {x_param}             ; Set X coordinate")
                elif isinstance(x_param, str) and x_param.startswith('v'):
                    x_type, x_offset = stack_frame.get_variable_location(x_param)
                    if x_offset == 0:
                        x_addr = "[FP]"
                    elif x_offset > 0:
                        x_addr = f"[FP+{x_offset}]"
                    else:
                        x_addr = f"[FP{x_offset}]"
                    code.extend([
                        f"    MOV R0, {x_addr}              ; Load X from {x_param}",
                        f"    MOV VX, R0                    ; Set X coordinate"
                    ])
                
                # Load y parameter into VY
                if isinstance(y_param, int):
                    code.append(f"    MOV VY, {y_param}             ; Set Y coordinate")
                elif isinstance(y_param, str) and y_param.startswith('v'):
                    y_type, y_offset = stack_frame.get_variable_location(y_param)
                    if y_offset == 0:
                        y_addr = "[FP]"
                    elif y_offset > 0:
                        y_addr = f"[FP+{y_offset}]"
                    else:
                        y_addr = f"[FP{y_offset}]"
                    code.extend([
                        f"    MOV R0, {y_addr}              ; Load Y from {y_param}",
                        f"    MOV VY, R0                    ; Set Y coordinate"
                    ])
                
                # Load color parameter 
                if isinstance(color_param, int):
                    code.append(f"    MOV R8, {color_param}         ; Set color")
                elif isinstance(color_param, str) and color_param.startswith('v'):
                    color_type, color_offset = stack_frame.get_variable_location(color_param)
                    if color_offset == 0:
                        color_addr = "[FP]"
                    elif color_offset > 0:
                        color_addr = f"[FP+{color_offset}]"
                    else:
                        color_addr = f"[FP{color_offset}]"
                    code.extend([
                        f"    MOV R0, {color_addr}          ; Load color from {color_param}",
                        f"    MOV R8, R0                    ; Set color"
                    ])
                
                # Set coordinate mode and print string
                code.extend([
                    f"    MOV VM, 0                     ; Set coordinate mode",
                    f"    TEXT P0, R8                   ; Print string"
                ])
        else:
            code.append(f"    ; TODO: Implement string function {function_name}")
        
        # Store return value if needed
        if result_var and result_var.startswith('v'):
            result_type, result_offset = stack_frame.get_variable_location(result_var)
            code.append(self._generate_direct_indexed_access('FP', result_offset, 'MOV', 'R0'))
        
        return code

    def _generate_builtin_sound_call(self, function_name: str, parameters: List, stack_frame: StackFrame, result_var: str = None) -> List[str]:
        """Generate code for builtin sound function calls."""
        code = []
        code.append(f"    ; TODO: Implement sound function {function_name}")
        return code
    
    def _generate_builtin_system_call(self, function_name: str, parameters: List, stack_frame: StackFrame, result_var: str = None) -> List[str]:
        """Generate code for builtin system function calls.""" 
        code = []
        
        if function_name == 'random':
            # Generate basic random number (0-65535)
            system_func = self.system_builtins.get_function('random')
            if system_func:
                asm_code = system_func()
                code.extend([
                    f"    {asm_code.strip()}",
                ])
        
        elif function_name == 'random_range':
            # Handle random range with min/max parameters
            if len(parameters) >= 2:
                min_param = parameters[0]
                max_param = parameters[1]
                
                # Check if both parameters are constants we can resolve
                min_is_constant = isinstance(min_param, int) or (isinstance(min_param, str) and min_param in self._constant_values)
                max_is_constant = isinstance(max_param, int) or (isinstance(max_param, str) and max_param in self._constant_values)
                
                if min_is_constant and max_is_constant:
                    # Both are constants - resolve and generate direct instruction
                    min_value = self._resolve_parameter_value(min_param, stack_frame)
                    max_value = self._resolve_parameter_value(max_param, stack_frame)
                    
                    system_func = self.system_builtins.get_function('random_range')
                    if system_func:
                        asm_code = system_func(min_value, max_value)
                        code.extend(asm_code.split('\n'))
                else:
                    # One or both are variables - need to load them first
                    code.append("    ; Generate random number with variable parameters")
                    
                    # Load min value
                    if isinstance(min_param, int):
                        code.append(f"    MOV P6, {min_param}               ; Load min constant")
                    elif isinstance(min_param, str) and min_param.startswith('v'):
                        if min_param in self._constant_values:
                            code.append(f"    MOV P6, {self._constant_values[min_param]}               ; Load resolved min constant")
                        else:
                            min_type, min_offset = stack_frame.get_variable_location(min_param)
                            # Use direct indexed addressing instead of deprecated address calculation
                            if min_offset == 0:
                                min_addr = "[FP]"
                            elif min_offset > 0:
                                min_addr = f"[FP+{min_offset}]"
                            else:
                                min_addr = f"[FP{min_offset}]"
                            code.append(f"    MOV P6, {min_addr}            ; Load min from {min_param}")
                    
                    # Load max value  
                    if isinstance(max_param, int):
                        code.append(f"    MOV P7, {max_param}               ; Load max constant")
                    elif isinstance(max_param, str) and max_param.startswith('v'):
                        if max_param in self._constant_values:
                            code.append(f"    MOV P7, {self._constant_values[max_param]}               ; Load resolved max constant")
                        else:
                            max_type, max_offset = stack_frame.get_variable_location(max_param)
                            if max_offset == 0:
                                max_addr = "[FP]"
                            elif max_offset > 0:
                                max_addr = f"[FP+{max_offset}]"
                            else:
                                max_addr = f"[FP{max_offset}]"
                            code.append(f"    MOV P7, {max_addr}            ; Load max from {max_param}")
                    
                    # Generate the random range instruction
                    code.append(f"    RNDR P0, P6, P7               ; Generate random between variables")
            else:
                code.append(f"    ; Error: random_range requires 2 parameters")
        
        elif function_name == 'halt':
            system_func = self.system_builtins.get_function('halt')
            if system_func:
                asm_code = system_func()
                code.extend(asm_code.split('\n'))
        
        else:
            # Try to find the function in system builtins
            system_func = self.system_builtins.get_function(function_name)
            if system_func:
                try:
                    # Call the function with appropriate parameters
                    if len(parameters) == 0:
                        asm_code = system_func()
                    elif len(parameters) == 1:
                        asm_code = system_func(self._resolve_parameter_value(parameters[0], stack_frame))
                    elif len(parameters) == 2:
                        asm_code = system_func(
                            self._resolve_parameter_value(parameters[0], stack_frame),
                            self._resolve_parameter_value(parameters[1], stack_frame)
                        )
                    else:
                        asm_code = f"; Error: Too many parameters for {function_name}"
                    
                    code.extend(asm_code.split('\n'))
                except Exception as e:
                    code.append(f"    ; Error calling {function_name}: {e}")
            else:
                code.append(f"    ; Unknown system function: {function_name}")
        
        # Store return value if needed
        if result_var and result_var.startswith('v'):
            result_type, result_offset = stack_frame.get_variable_location(result_var)
            code.append(self._generate_direct_indexed_access('FP', result_offset, 'MOV', 'P0'))
        
        return code

    def _resolve_parameter_value(self, param, stack_frame: StackFrame):
        """Resolve a parameter to its actual value for builtin functions."""
        if isinstance(param, int):
            return param
        elif isinstance(param, str):
            if param.startswith('v'):
                # This is a variable - check if it's a constant we can resolve
                if param in self._constant_values:
                    return self._constant_values[param]
                else:
                    # Return the variable name for register-based operations
                    return param
            else:
                # String literal or register name
                return param
        else:
            return param

    def _order_blocks_for_execution(self, blocks: List) -> List:
        """Order basic blocks for correct execution flow."""
        # Simple ordering: put entry first, then others in order they appear
        # This works for simple control flow but could be improved for complex cases
        ordered = []
        entry_block = None
        other_blocks = []
        
        for block in blocks:
            if block.name == "entry":
                entry_block = block
            else:
                other_blocks.append(block)
        
        # Put entry first
        if entry_block:
            ordered.append(entry_block)
        
        # Add other blocks in original order
        # For more complex control flow, we'd need proper CFG analysis
        ordered.extend(other_blocks)
        
        return ordered

    def _should_terminate_function(self, block, function) -> bool:
        """Determine if a block should cause function termination."""
        # Disable automatic termination for now to debug control flow
        return False
    
    def _block_has_jump(self, block) -> bool:
        """Check if block has any jump instruction."""
        if not block.instructions:
            return False
        for instr in block.instructions:
            if hasattr(instr, 'op') and instr.op in ['jmp', 'br', 'call', 'ret', 'return']:
                if instr.op in ['jmp', 'br', 'ret', 'return']:
                    return True
        return False

    def _escape_string_for_assembly(self, string_value: str) -> str:
        """Escape string characters for assembly output."""
        escaped = ""
        for char in string_value:
            if char == '\n':
                escaped += '\\n'
            elif char == '\t':
                escaped += '\\t'
            elif char == '\r':
                escaped += '\\r'
            elif char == '\\':
                escaped += '\\\\'
            elif char == '"':
                escaped += '\\"'
            else:
                escaped += char
        return escaped

    def _generate_stack_array_set(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate array element assignment using pure stack operations."""
        code = []
        
        if len(instr.operands) != 3:
            logger.error(f"array_set expects 3 operands (array, index, value), got {len(instr.operands)}")
            return ["    ; ERROR: Invalid array_set operands"]
        
        array_var = instr.operands[0]
        index_var = instr.operands[1]
        value_var = instr.operands[2]
        
        # Get array base address
        array_location_type, array_offset = stack_frame.get_variable_location(array_var)
        
        # Load index into R0 for address calculation
        index_location_type, index_offset = stack_frame.get_variable_location(index_var)
        if index_location_type == 'local':
            code.append(f"    MOV R0, [FP{index_offset}]    ; Load array index")
        
        # Load value into R1
        value_location_type, value_offset = stack_frame.get_variable_location(value_var)
        if value_location_type == 'local':
            code.append(f"    MOV R1, [FP{value_offset}]    ; Load value to store")
        
        # Calculate array element address: array_base + (index * 2)
        code.extend([
            "    SHL R0, 1           ; Multiply index by 2 (16-bit elements)",
            f"    MOV P0, FP",
            f"    ADD P0, {array_offset}  ; Array base address", 
            "    ADD P0, R0          ; Element address = base + (index * 2)",
            "    MOV [P0], R1        ; Store value to array element"
        ])
        
        return code

    def _generate_stack_array_get(self, instr: IRInstruction, stack_frame: StackFrame) -> List[str]:
        """Generate array element access using pure stack operations."""
        code = []
        
        if len(instr.operands) != 2:
            logger.error(f"array_get expects 2 operands (array, index), got {len(instr.operands)}")
            return ["    ; ERROR: Invalid array_get operands"]
        
        array_var = instr.operands[0]
        index_var = instr.operands[1]
        result_var = instr.result
        
        if not result_var:
            logger.error("array_get missing result variable")
            return ["    ; ERROR: array_get missing result"]
        
        # Get array base address
        array_location_type, array_offset = stack_frame.get_variable_location(array_var)
        
        # Load index into R0 for address calculation
        index_location_type, index_offset = stack_frame.get_variable_location(index_var)
        if index_location_type == 'local':
            code.append(f"    MOV R0, [FP{index_offset}]    ; Load array index")
        
        # Calculate array element address: array_base + (index * 2)
        code.extend([
            "    SHL R0, 1           ; Multiply index by 2 (16-bit elements)",
            f"    MOV P0, FP",
            f"    ADD P0, {array_offset}  ; Array base address", 
            "    ADD P0, R0          ; Element address = base + (index * 2)",
            "    MOV R1, [P0]        ; Load value from array element"
        ])
        
        # Store result to stack variable
        result_location_type, result_offset = stack_frame.get_variable_location(result_var)
        if result_location_type == 'local':
            code.append(f"    MOV [FP{result_offset}], R1   ; Store result")
        
        return code
        
        return ordered
