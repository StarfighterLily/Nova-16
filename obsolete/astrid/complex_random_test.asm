; Generated by Astrid Pure Stack-Centric Compiler
; Architecture: Nova-16 with pure stack-first approach
; Variables stored on stack, minimal register usage
; Stack Layout: [locals][FP][return_addr][params]

main:
    MOV SP, 0xF000                ; Initialize stack pointer to safe area
    MOV FP, SP                    ; Initialize frame pointer for main
    SUB SP, 186      ; Allocate 186 bytes for locals
    MOV P0, FP                ; Load base pointer
    SUB P0, 4              ; Subtract for negative offset (-4)
    MOV R0, 1         ; Load constant 1
    MOV [P0], R0                  ; Store to local variable v0
    MOV VL, 1         ; Set active layer
    MOV P0, FP                ; Load base pointer
    SUB P0, 6              ; Subtract for negative offset (-6)
    MOV [P0], R0                  ; Store return value to v1
    MOV P0, FP                ; Load base pointer
    SUB P0, 28              ; Subtract for negative offset (-28)
    MOV R0, 0         ; Load constant 0
    MOV [P0], R0                  ; Store to local variable v2
    ; TODO: Implement graphics function clear_screen
    MOV P0, FP                ; Load base pointer
    SUB P0, 50              ; Subtract for negative offset (-50)
    MOV [P0], R0                  ; Store return value to v3
    MOV P0, FP                ; Load base pointer
    SUB P0, 28              ; Subtract for negative offset (-28)
    MOV P2, [P0]                  ; Load from v2 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 72              ; Subtract for negative offset (-72)
    MOV [P1], P2                  ; Store to v4 (16-bit)
    JMP for_header_0                  ; Unconditional jump
for_header_0:
    MOV P0, FP                ; Load base pointer
    SUB P0, 94              ; Subtract for negative offset (-94)
    MOV R0, 10         ; Load constant 10
    MOV [P0], R0                  ; Store to local variable v5
    MOV P1, FP                ; Load base pointer
    SUB P1, 72              ; Subtract for negative offset (-72)
    MOV P0, [P1]                 ; Load left operand v4 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 94              ; Subtract for negative offset (-94)
    MOV P1, [P2]                  ; Load right operand v5 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_1     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_2        ; Skip true case
cmp_true_1:
    MOV R0, 1                     ; Set true result
cmp_end_2:
    MOV P0, FP                ; Load base pointer
    SUB P0, 116              ; Subtract for negative offset (-116)
    MOV [P0], R0                  ; Store comparison result to v6
    MOV P0, FP                ; Load base pointer
    SUB P0, 116              ; Subtract for negative offset (-116)
    MOV R0, [P0]                  ; Load condition v6
    CMP R0, 0                     ; Test condition
    JNZ for_body_1             ; Jump to true branch if non-zero
    JMP for_exit_2            ; Jump to false branch
for_body_1:
    MOV P0, FP                ; Load base pointer
    SUB P0, 138              ; Subtract for negative offset (-138)
    MOV R0, 255         ; Load constant 255
    MOV [P0], R0                  ; Store to local variable v7

; Generate random number between 0 and 255 (8-bit)
RNDR P0, 0, 255
    MOV P1, FP                ; Load base pointer
    SUB P1, 160              ; Subtract for negative offset (-160)
    MOV [P1], P0                  ; Store return value to v8
    MOV P0, FP                ; Load base pointer
    SUB P0, 160              ; Subtract for negative offset (-160)
    MOV P2, [P0]                  ; Load from v8 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 182              ; Subtract for negative offset (-182)
    MOV [P1], P2                  ; Store to v9 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 8              ; Subtract for negative offset (-8)
    MOV R0, 191         ; Load constant 191
    MOV [P0], R0                  ; Store to local variable v10

; Generate random number between 0 and 191 (8-bit)
RNDR P0, 0, 191
    MOV P1, FP                ; Load base pointer
    SUB P1, 10              ; Subtract for negative offset (-10)
    MOV [P1], P0                  ; Store return value to v11
    MOV P0, FP                ; Load base pointer
    SUB P0, 10              ; Subtract for negative offset (-10)
    MOV P2, [P0]                  ; Load from v11 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 12              ; Subtract for negative offset (-12)
    MOV [P1], P2                  ; Store to v12 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 14              ; Subtract for negative offset (-14)
    MOV R0, 31         ; Load constant 31
    MOV [P0], R0                  ; Store to local variable v13

; Generate random number between 1 and 31 (8-bit)
RNDR P0, 1, 31
    MOV P1, FP                ; Load base pointer
    SUB P1, 16              ; Subtract for negative offset (-16)
    MOV [P1], P0                  ; Store return value to v14
    MOV P0, FP                ; Load base pointer
    SUB P0, 16              ; Subtract for negative offset (-16)
    MOV P2, [P0]                  ; Load from v14 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 18              ; Subtract for negative offset (-18)
    MOV [P1], P2                  ; Store to v15 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 20              ; Subtract for negative offset (-20)
    MOV R0, 2         ; Load constant 2
    MOV [P0], R0                  ; Store to local variable v16
    MOV P0, FP                ; Load base pointer
    SUB P0, 182              ; Subtract for negative offset (-182)
    MOV R0, [P0]                  ; Load left operand v9
    MOV P1, FP                ; Load base pointer
    SUB P1, 20              ; Subtract for negative offset (-20)
    MOV R1, [P1]                  ; Load right operand v16
    DIV R0, R1               ; / operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 22              ; Subtract for negative offset (-22)
    MOV [P0], R0                  ; Store result to v17
    MOV P0, FP                ; Load base pointer
    SUB P0, 24              ; Subtract for negative offset (-24)
    MOV R0, 50         ; Load constant 50
    MOV [P0], R0                  ; Store to local variable v18

; Generate random number between 0 and 50 (8-bit)
RNDR P0, 0, 50
    MOV P1, FP                ; Load base pointer
    SUB P1, 26              ; Subtract for negative offset (-26)
    MOV [P1], P0                  ; Store return value to v19
    MOV P0, FP                ; Load base pointer
    SUB P0, 22              ; Subtract for negative offset (-22)
    MOV R0, [P0]                  ; Load left operand v17
    MOV P1, FP                ; Load base pointer
    SUB P1, 26              ; Subtract for negative offset (-26)
    MOV R1, [P1]                  ; Load right operand v19
    ADD R0, R1               ; + operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 30              ; Subtract for negative offset (-30)
    MOV [P0], R0                  ; Store result to v20
    MOV P0, FP                ; Load base pointer
    SUB P0, 30              ; Subtract for negative offset (-30)
    MOV P2, [P0]                  ; Load from v20 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 32              ; Subtract for negative offset (-32)
    MOV [P1], P2                  ; Store to v21 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 34              ; Subtract for negative offset (-34)
    MOV R0, 3         ; Load constant 3
    MOV [P0], R0                  ; Store to local variable v22
    MOV P0, FP                ; Load base pointer
    SUB P0, 12              ; Subtract for negative offset (-12)
    MOV R0, [P0]                  ; Load left operand v12
    MOV P1, FP                ; Load base pointer
    SUB P1, 34              ; Subtract for negative offset (-34)
    MOV R1, [P1]                  ; Load right operand v22
    DIV R0, R1               ; / operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 36              ; Subtract for negative offset (-36)
    MOV [P0], R0                  ; Store result to v23
    MOV P0, FP                ; Load base pointer
    SUB P0, 38              ; Subtract for negative offset (-38)
    MOV R0, 30         ; Load constant 30
    MOV [P0], R0                  ; Store to local variable v24

; Generate random number between 0 and 30 (8-bit)
RNDR P0, 0, 30
    MOV P1, FP                ; Load base pointer
    SUB P1, 40              ; Subtract for negative offset (-40)
    MOV [P1], P0                  ; Store return value to v25
    MOV P0, FP                ; Load base pointer
    SUB P0, 36              ; Subtract for negative offset (-36)
    MOV R0, [P0]                  ; Load left operand v23
    MOV P1, FP                ; Load base pointer
    SUB P1, 40              ; Subtract for negative offset (-40)
    MOV R1, [P1]                  ; Load right operand v25
    ADD R0, R1               ; + operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 42              ; Subtract for negative offset (-42)
    MOV [P0], R0                  ; Store result to v26
    MOV P0, FP                ; Load base pointer
    SUB P0, 42              ; Subtract for negative offset (-42)
    MOV P2, [P0]                  ; Load from v26 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 44              ; Subtract for negative offset (-44)
    MOV [P1], P2                  ; Store to v27 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 32              ; Subtract for negative offset (-32)
    MOV R0, [P0]                  ; Load X from v21
    MOV VX, R0                    ; Set X coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 44              ; Subtract for negative offset (-44)
    MOV R0, [P0]                  ; Load Y from v27
    MOV VY, R0                    ; Set Y coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 18              ; Subtract for negative offset (-18)
    MOV R0, [P0]                  ; Load color from v15
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV P0, FP                ; Load base pointer
    SUB P0, 46              ; Subtract for negative offset (-46)
    MOV [P0], R0                  ; Store return value to v28
    JMP for_increment_3                  ; Unconditional jump
for_increment_3:
    MOV P0, FP                ; Load base pointer
    SUB P0, 72              ; Subtract for negative offset (-72)
    MOV P1, [P0]                  ; Load current 16-bit value of v4
    ADD P1, 1                     ; Increment 16-bit
    MOV [P0], P1                  ; Store 16-bit result back to v4
    JMP for_header_0                  ; Unconditional jump
for_exit_2:
    MOV P0, FP                ; Load base pointer
    SUB P0, 48              ; Subtract for negative offset (-48)
    MOV R0, 100         ; Load constant 100
    MOV [P0], R0                  ; Store to local variable v29

; Generate random number between 0 and 100 (8-bit)
RNDR P0, 0, 100
    MOV P1, FP                ; Load base pointer
    SUB P1, 52              ; Subtract for negative offset (-52)
    MOV [P1], P0                  ; Store return value to v30
    MOV P0, FP                ; Load base pointer
    SUB P0, 52              ; Subtract for negative offset (-52)
    MOV P2, [P0]                  ; Load from v30 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 54              ; Subtract for negative offset (-54)
    MOV [P1], P2                  ; Store to v31 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 56              ; Subtract for negative offset (-56)
    MOV R0, 25         ; Load constant 25
    MOV [P0], R0                  ; Store to local variable v32
    MOV P1, FP                ; Load base pointer
    SUB P1, 54              ; Subtract for negative offset (-54)
    MOV P0, [P1]                 ; Load left operand v31 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 56              ; Subtract for negative offset (-56)
    MOV P1, [P2]                  ; Load right operand v32 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_3     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_4        ; Skip true case
cmp_true_3:
    MOV R0, 1                     ; Set true result
cmp_end_4:
    MOV P0, FP                ; Load base pointer
    SUB P0, 58              ; Subtract for negative offset (-58)
    MOV [P0], R0                  ; Store comparison result to v33
    MOV P0, FP                ; Load base pointer
    SUB P0, 58              ; Subtract for negative offset (-58)
    MOV R0, [P0]                  ; Load condition v33
    CMP R0, 0                     ; Test condition
    JNZ if_then_4             ; Jump to true branch if non-zero
    JMP if_else_5            ; Jump to false branch
if_then_4:
    MOV P0, FP                ; Load base pointer
    SUB P0, 28              ; Subtract for negative offset (-28)
    MOV P2, [P0]                  ; Load from v2 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 60              ; Subtract for negative offset (-60)
    MOV [P1], P2                  ; Store to v34 (16-bit)
    JMP for_header_7                  ; Unconditional jump
if_else_5:
    MOV P1, FP                ; Load base pointer
    SUB P1, 54              ; Subtract for negative offset (-54)
    MOV P0, [P1]                 ; Load left operand v31 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 24              ; Subtract for negative offset (-24)
    MOV P1, [P2]                  ; Load right operand v18 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_5     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_6        ; Skip true case
cmp_true_5:
    MOV R0, 1                     ; Set true result
cmp_end_6:
    MOV P0, FP                ; Load base pointer
    SUB P0, 74              ; Subtract for negative offset (-74)
    MOV [P0], R0                  ; Store comparison result to v40
    MOV P0, FP                ; Load base pointer
    SUB P0, 74              ; Subtract for negative offset (-74)
    MOV R0, [P0]                  ; Load condition v40
    CMP R0, 0                     ; Test condition
    JNZ if_then_11             ; Jump to true branch if non-zero
    JMP if_else_12            ; Jump to false branch
if_merge_6:

; Generate random number between 1 and 50 (8-bit)
RNDR P0, 1, 50
    MOV P1, FP                ; Load base pointer
    SUB P1, 130              ; Subtract for negative offset (-130)
    MOV [P1], P0                  ; Store return value to v66
    MOV P0, FP                ; Load base pointer
    SUB P0, 130              ; Subtract for negative offset (-130)
    MOV P2, [P0]                  ; Load from v66 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 132              ; Subtract for negative offset (-132)
    MOV [P1], P2                  ; Store to v67 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 134              ; Subtract for negative offset (-134)
    MOV R0, 51         ; Load constant 51
    MOV [P0], R0                  ; Store to local variable v68

; Generate random number between 51 and 100 (8-bit)
RNDR P0, 51, 100
    MOV P1, FP                ; Load base pointer
    SUB P1, 136              ; Subtract for negative offset (-136)
    MOV [P1], P0                  ; Store return value to v69
    MOV P0, FP                ; Load base pointer
    SUB P0, 136              ; Subtract for negative offset (-136)
    MOV P2, [P0]                  ; Load from v69 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 140              ; Subtract for negative offset (-140)
    MOV [P1], P2                  ; Store to v70 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 132              ; Subtract for negative offset (-132)
    MOV R0, [P0]                  ; Load left operand v67
    MOV P1, FP                ; Load base pointer
    SUB P1, 140              ; Subtract for negative offset (-140)
    MOV R1, [P1]                  ; Load right operand v70
    ADD R0, R1               ; + operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 142              ; Subtract for negative offset (-142)
    MOV [P0], R0                  ; Store result to v71
    MOV P0, FP                ; Load base pointer
    SUB P0, 142              ; Subtract for negative offset (-142)
    MOV P2, [P0]                  ; Load from v71 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 144              ; Subtract for negative offset (-144)
    MOV [P1], P2                  ; Store to v72 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 140              ; Subtract for negative offset (-140)
    MOV R0, [P0]                  ; Load left operand v70
    MOV P1, FP                ; Load base pointer
    SUB P1, 132              ; Subtract for negative offset (-132)
    MOV R1, [P1]                  ; Load right operand v67
    SUB R0, R1               ; - operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 146              ; Subtract for negative offset (-146)
    MOV [P0], R0                  ; Store result to v73
    MOV P0, FP                ; Load base pointer
    SUB P0, 146              ; Subtract for negative offset (-146)
    MOV P2, [P0]                  ; Load from v73 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 148              ; Subtract for negative offset (-148)
    MOV [P1], P2                  ; Store to v74 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 144              ; Subtract for negative offset (-144)
    MOV P0, [P1]                 ; Load left operand v72 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 90              ; Subtract for negative offset (-90)
    MOV P1, [P2]                  ; Load right operand v48 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JGT cmp_true_7     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_8        ; Skip true case
cmp_true_7:
    MOV R0, 1                     ; Set true result
cmp_end_8:
    MOV P0, FP                ; Load base pointer
    SUB P0, 150              ; Subtract for negative offset (-150)
    MOV [P0], R0                  ; Store comparison result to v75
    MOV P0, FP                ; Load base pointer
    SUB P0, 150              ; Subtract for negative offset (-150)
    MOV R0, [P0]                  ; Load condition v75
    CMP R0, 0                     ; Test condition
    JNZ if_then_29             ; Jump to true branch if non-zero
    JMP if_merge_31            ; Jump to false branch
for_header_7:
    MOV P0, FP                ; Load base pointer
    SUB P0, 62              ; Subtract for negative offset (-62)
    MOV R0, 5         ; Load constant 5
    MOV [P0], R0                  ; Store to local variable v35
    MOV P1, FP                ; Load base pointer
    SUB P1, 60              ; Subtract for negative offset (-60)
    MOV P0, [P1]                 ; Load left operand v34 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 62              ; Subtract for negative offset (-62)
    MOV P1, [P2]                  ; Load right operand v35 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_9     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_10        ; Skip true case
cmp_true_9:
    MOV R0, 1                     ; Set true result
cmp_end_10:
    MOV P0, FP                ; Load base pointer
    SUB P0, 64              ; Subtract for negative offset (-64)
    MOV [P0], R0                  ; Store comparison result to v36
    MOV P0, FP                ; Load base pointer
    SUB P0, 64              ; Subtract for negative offset (-64)
    MOV R0, [P0]                  ; Load condition v36
    CMP R0, 0                     ; Test condition
    JNZ for_body_8             ; Jump to true branch if non-zero
    JMP for_exit_9            ; Jump to false branch
for_body_8:

; Generate random number between 10 and 50 (8-bit)
RNDR P0, 10, 50
    MOV P1, FP                ; Load base pointer
    SUB P1, 66              ; Subtract for negative offset (-66)
    MOV [P1], P0                  ; Store return value to v37

; Generate random number between 10 and 50 (8-bit)
RNDR P0, 10, 50
    MOV P1, FP                ; Load base pointer
    SUB P1, 68              ; Subtract for negative offset (-68)
    MOV [P1], P0                  ; Store return value to v38
    MOV P0, FP                ; Load base pointer
    SUB P0, 66              ; Subtract for negative offset (-66)
    MOV R0, [P0]                  ; Load X from v37
    MOV VX, R0                    ; Set X coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 68              ; Subtract for negative offset (-68)
    MOV R0, [P0]                  ; Load Y from v38
    MOV VY, R0                    ; Set Y coordinate
    MOV R0, 31         ; Load color constant
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV P0, FP                ; Load base pointer
    SUB P0, 70              ; Subtract for negative offset (-70)
    MOV [P0], R0                  ; Store return value to v39
    JMP for_increment_10                  ; Unconditional jump
for_increment_10:
    MOV P0, FP                ; Load base pointer
    SUB P0, 60              ; Subtract for negative offset (-60)
    MOV P1, [P0]                  ; Load current 16-bit value of v34
    ADD P1, 1                     ; Increment 16-bit
    MOV [P0], P1                  ; Store 16-bit result back to v34
    JMP for_header_7                  ; Unconditional jump
for_exit_9:
    JMP if_merge_6                  ; Unconditional jump
if_then_11:
    MOV P0, FP                ; Load base pointer
    SUB P0, 28              ; Subtract for negative offset (-28)
    MOV P2, [P0]                  ; Load from v2 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 76              ; Subtract for negative offset (-76)
    MOV [P1], P2                  ; Store to v41 (16-bit)
    JMP for_header_14                  ; Unconditional jump
if_else_12:
    MOV P0, FP                ; Load base pointer
    SUB P0, 90              ; Subtract for negative offset (-90)
    MOV R0, 75         ; Load constant 75
    MOV [P0], R0                  ; Store to local variable v48
    MOV P1, FP                ; Load base pointer
    SUB P1, 54              ; Subtract for negative offset (-54)
    MOV P0, [P1]                 ; Load left operand v31 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 90              ; Subtract for negative offset (-90)
    MOV P1, [P2]                  ; Load right operand v48 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_11     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_12        ; Skip true case
cmp_true_11:
    MOV R0, 1                     ; Set true result
cmp_end_12:
    MOV P0, FP                ; Load base pointer
    SUB P0, 92              ; Subtract for negative offset (-92)
    MOV [P0], R0                  ; Store comparison result to v49
    MOV P0, FP                ; Load base pointer
    SUB P0, 92              ; Subtract for negative offset (-92)
    MOV R0, [P0]                  ; Load condition v49
    CMP R0, 0                     ; Test condition
    JNZ if_then_18             ; Jump to true branch if non-zero
    JMP if_else_19            ; Jump to false branch
if_merge_13:
    JMP if_merge_6                  ; Unconditional jump
for_header_14:
    MOV P1, FP                ; Load base pointer
    SUB P1, 76              ; Subtract for negative offset (-76)
    MOV P0, [P1]                 ; Load left operand v41 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 62              ; Subtract for negative offset (-62)
    MOV P1, [P2]                  ; Load right operand v35 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_13     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_14        ; Skip true case
cmp_true_13:
    MOV R0, 1                     ; Set true result
cmp_end_14:
    MOV P0, FP                ; Load base pointer
    SUB P0, 78              ; Subtract for negative offset (-78)
    MOV [P0], R0                  ; Store comparison result to v42
    MOV P0, FP                ; Load base pointer
    SUB P0, 78              ; Subtract for negative offset (-78)
    MOV R0, [P0]                  ; Load condition v42
    CMP R0, 0                     ; Test condition
    JNZ for_body_15             ; Jump to true branch if non-zero
    JMP for_exit_16            ; Jump to false branch
for_body_15:
    MOV P0, FP                ; Load base pointer
    SUB P0, 80              ; Subtract for negative offset (-80)
    MOV R0, 60         ; Load constant 60
    MOV [P0], R0                  ; Store to local variable v43

; Generate random number between 60 and 100 (8-bit)
RNDR P0, 60, 100
    MOV P1, FP                ; Load base pointer
    SUB P1, 82              ; Subtract for negative offset (-82)
    MOV [P1], P0                  ; Store return value to v44

; Generate random number between 10 and 50 (8-bit)
RNDR P0, 10, 50
    MOV P1, FP                ; Load base pointer
    SUB P1, 84              ; Subtract for negative offset (-84)
    MOV [P1], P0                  ; Store return value to v45
    MOV P0, FP                ; Load base pointer
    SUB P0, 86              ; Subtract for negative offset (-86)
    MOV R0, 28         ; Load constant 28
    MOV [P0], R0                  ; Store to local variable v46
    MOV P0, FP                ; Load base pointer
    SUB P0, 82              ; Subtract for negative offset (-82)
    MOV R0, [P0]                  ; Load X from v44
    MOV VX, R0                    ; Set X coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 84              ; Subtract for negative offset (-84)
    MOV R0, [P0]                  ; Load Y from v45
    MOV VY, R0                    ; Set Y coordinate
    MOV R0, 28         ; Load color constant
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV P0, FP                ; Load base pointer
    SUB P0, 88              ; Subtract for negative offset (-88)
    MOV [P0], R0                  ; Store return value to v47
    JMP for_increment_17                  ; Unconditional jump
for_increment_17:
    MOV P0, FP                ; Load base pointer
    SUB P0, 76              ; Subtract for negative offset (-76)
    MOV P1, [P0]                  ; Load current 16-bit value of v41
    ADD P1, 1                     ; Increment 16-bit
    MOV [P0], P1                  ; Store 16-bit result back to v41
    JMP for_header_14                  ; Unconditional jump
for_exit_16:
    JMP if_merge_13                  ; Unconditional jump
if_then_18:
    MOV P0, FP                ; Load base pointer
    SUB P0, 28              ; Subtract for negative offset (-28)
    MOV P2, [P0]                  ; Load from v2 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 96              ; Subtract for negative offset (-96)
    MOV [P1], P2                  ; Store to v50 (16-bit)
    JMP for_header_21                  ; Unconditional jump
if_else_19:
    MOV P0, FP                ; Load base pointer
    SUB P0, 28              ; Subtract for negative offset (-28)
    MOV P2, [P0]                  ; Load from v2 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 112              ; Subtract for negative offset (-112)
    MOV [P1], P2                  ; Store to v58 (16-bit)
    JMP for_header_25                  ; Unconditional jump
if_merge_20:
    JMP if_merge_13                  ; Unconditional jump
for_header_21:
    MOV P1, FP                ; Load base pointer
    SUB P1, 96              ; Subtract for negative offset (-96)
    MOV P0, [P1]                 ; Load left operand v50 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 62              ; Subtract for negative offset (-62)
    MOV P1, [P2]                  ; Load right operand v35 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_15     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_16        ; Skip true case
cmp_true_15:
    MOV R0, 1                     ; Set true result
cmp_end_16:
    MOV P0, FP                ; Load base pointer
    SUB P0, 98              ; Subtract for negative offset (-98)
    MOV [P0], R0                  ; Store comparison result to v51
    MOV P0, FP                ; Load base pointer
    SUB P0, 98              ; Subtract for negative offset (-98)
    MOV R0, [P0]                  ; Load condition v51
    CMP R0, 0                     ; Test condition
    JNZ for_body_22             ; Jump to true branch if non-zero
    JMP for_exit_23            ; Jump to false branch
for_body_22:
    MOV P0, FP                ; Load base pointer
    SUB P0, 100              ; Subtract for negative offset (-100)
    MOV R0, 110         ; Load constant 110
    MOV [P0], R0                  ; Store to local variable v52
    MOV P0, FP                ; Load base pointer
    SUB P0, 102              ; Subtract for negative offset (-102)
    MOV R0, 150         ; Load constant 150
    MOV [P0], R0                  ; Store to local variable v53

; Generate random number between 110 and 150 (8-bit)
RNDR P0, 110, 150
    MOV P1, FP                ; Load base pointer
    SUB P1, 104              ; Subtract for negative offset (-104)
    MOV [P1], P0                  ; Store return value to v54

; Generate random number between 10 and 50 (8-bit)
RNDR P0, 10, 50
    MOV P1, FP                ; Load base pointer
    SUB P1, 106              ; Subtract for negative offset (-106)
    MOV [P1], P0                  ; Store return value to v55
    MOV P0, FP                ; Load base pointer
    SUB P0, 108              ; Subtract for negative offset (-108)
    MOV R0, 20         ; Load constant 20
    MOV [P0], R0                  ; Store to local variable v56
    MOV P0, FP                ; Load base pointer
    SUB P0, 104              ; Subtract for negative offset (-104)
    MOV R0, [P0]                  ; Load X from v54
    MOV VX, R0                    ; Set X coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 106              ; Subtract for negative offset (-106)
    MOV R0, [P0]                  ; Load Y from v55
    MOV VY, R0                    ; Set Y coordinate
    MOV R0, 20         ; Load color constant
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV P0, FP                ; Load base pointer
    SUB P0, 110              ; Subtract for negative offset (-110)
    MOV [P0], R0                  ; Store return value to v57
    JMP for_increment_24                  ; Unconditional jump
for_increment_24:
    MOV P0, FP                ; Load base pointer
    SUB P0, 96              ; Subtract for negative offset (-96)
    MOV P1, [P0]                  ; Load current 16-bit value of v50
    ADD P1, 1                     ; Increment 16-bit
    MOV [P0], P1                  ; Store 16-bit result back to v50
    JMP for_header_21                  ; Unconditional jump
for_exit_23:
    JMP if_merge_20                  ; Unconditional jump
for_header_25:
    MOV P1, FP                ; Load base pointer
    SUB P1, 112              ; Subtract for negative offset (-112)
    MOV P0, [P1]                 ; Load left operand v58 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 62              ; Subtract for negative offset (-62)
    MOV P1, [P2]                  ; Load right operand v35 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_17     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_18        ; Skip true case
cmp_true_17:
    MOV R0, 1                     ; Set true result
cmp_end_18:
    MOV P0, FP                ; Load base pointer
    SUB P0, 114              ; Subtract for negative offset (-114)
    MOV [P0], R0                  ; Store comparison result to v59
    MOV P0, FP                ; Load base pointer
    SUB P0, 114              ; Subtract for negative offset (-114)
    MOV R0, [P0]                  ; Load condition v59
    CMP R0, 0                     ; Test condition
    JNZ for_body_26             ; Jump to true branch if non-zero
    JMP for_exit_27            ; Jump to false branch
for_body_26:
    MOV P0, FP                ; Load base pointer
    SUB P0, 118              ; Subtract for negative offset (-118)
    MOV R0, 160         ; Load constant 160
    MOV [P0], R0                  ; Store to local variable v60
    MOV P0, FP                ; Load base pointer
    SUB P0, 120              ; Subtract for negative offset (-120)
    MOV R0, 200         ; Load constant 200
    MOV [P0], R0                  ; Store to local variable v61

; Generate random number between 160 and 200 (8-bit)
RNDR P0, 160, 200
    MOV P1, FP                ; Load base pointer
    SUB P1, 122              ; Subtract for negative offset (-122)
    MOV [P1], P0                  ; Store return value to v62

; Generate random number between 10 and 50 (8-bit)
RNDR P0, 10, 50
    MOV P1, FP                ; Load base pointer
    SUB P1, 124              ; Subtract for negative offset (-124)
    MOV [P1], P0                  ; Store return value to v63
    MOV P0, FP                ; Load base pointer
    SUB P0, 126              ; Subtract for negative offset (-126)
    MOV R0, 15         ; Load constant 15
    MOV [P0], R0                  ; Store to local variable v64
    MOV P0, FP                ; Load base pointer
    SUB P0, 122              ; Subtract for negative offset (-122)
    MOV R0, [P0]                  ; Load X from v62
    MOV VX, R0                    ; Set X coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 124              ; Subtract for negative offset (-124)
    MOV R0, [P0]                  ; Load Y from v63
    MOV VY, R0                    ; Set Y coordinate
    MOV R0, 15         ; Load color constant
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV P0, FP                ; Load base pointer
    SUB P0, 128              ; Subtract for negative offset (-128)
    MOV [P0], R0                  ; Store return value to v65
    JMP for_increment_28                  ; Unconditional jump
for_increment_28:
    MOV P0, FP                ; Load base pointer
    SUB P0, 112              ; Subtract for negative offset (-112)
    MOV P1, [P0]                  ; Load current 16-bit value of v58
    ADD P1, 1                     ; Increment 16-bit
    MOV [P0], P1                  ; Store 16-bit result back to v58
    JMP for_header_25                  ; Unconditional jump
for_exit_27:
    JMP if_merge_20                  ; Unconditional jump
if_then_29:

; Generate random number between 1 and 31 (8-bit)
RNDR P0, 1, 31
    MOV P1, FP                ; Load base pointer
    SUB P1, 152              ; Subtract for negative offset (-152)
    MOV [P1], P0                  ; Store return value to v76
    MOV VX, 100             ; Set X coordinate
    MOV VY, 100             ; Set Y coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 152              ; Subtract for negative offset (-152)
    MOV R0, [P0]                  ; Load color from v76
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV P0, FP                ; Load base pointer
    SUB P0, 154              ; Subtract for negative offset (-154)
    MOV [P0], R0                  ; Store return value to v77
    JMP if_merge_31                  ; Unconditional jump
if_merge_31:
    MOV P1, FP                ; Load base pointer
    SUB P1, 148              ; Subtract for negative offset (-148)
    MOV P0, [P1]                 ; Load left operand v74 as 16-bit
    MOV P2, FP                ; Load base pointer
    SUB P2, 56              ; Subtract for negative offset (-56)
    MOV P1, [P2]                  ; Load right operand v32 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JGT cmp_true_19     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_20        ; Skip true case
cmp_true_19:
    MOV R0, 1                     ; Set true result
cmp_end_20:
    MOV P0, FP                ; Load base pointer
    SUB P0, 156              ; Subtract for negative offset (-156)
    MOV [P0], R0                  ; Store comparison result to v78
    MOV P0, FP                ; Load base pointer
    SUB P0, 156              ; Subtract for negative offset (-156)
    MOV R0, [P0]                  ; Load condition v78
    CMP R0, 0                     ; Test condition
    JNZ if_then_32             ; Jump to true branch if non-zero
    JMP if_merge_34            ; Jump to false branch
if_then_32:
    MOV P0, FP                ; Load base pointer
    SUB P0, 158              ; Subtract for negative offset (-158)
    MOV R0, 120         ; Load constant 120
    MOV [P0], R0                  ; Store to local variable v79

; Generate random number between 1 and 31 (8-bit)
RNDR P0, 1, 31
    MOV P1, FP                ; Load base pointer
    SUB P1, 162              ; Subtract for negative offset (-162)
    MOV [P1], P0                  ; Store return value to v80
    MOV VX, 120             ; Set X coordinate
    MOV VY, 120             ; Set Y coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 162              ; Subtract for negative offset (-162)
    MOV R0, [P0]                  ; Load color from v80
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV P0, FP                ; Load base pointer
    SUB P0, 164              ; Subtract for negative offset (-164)
    MOV [P0], R0                  ; Store return value to v81
    JMP if_merge_34                  ; Unconditional jump
if_merge_34:

; Generate random number between 0 and 10 (8-bit)
RNDR P0, 0, 10
    MOV P1, FP                ; Load base pointer
    SUB P1, 166              ; Subtract for negative offset (-166)
    MOV [P1], P0                  ; Store return value to v82

; Generate random number between 1 and 5 (8-bit)
RNDR P0, 1, 5
    MOV P1, FP                ; Load base pointer
    SUB P1, 168              ; Subtract for negative offset (-168)
    MOV [P1], P0                  ; Store return value to v83
    MOV P0, FP                ; Load base pointer
    SUB P0, 166              ; Subtract for negative offset (-166)
    MOV R0, [P0]                  ; Load left operand v82
    MOV P1, FP                ; Load base pointer
    SUB P1, 168              ; Subtract for negative offset (-168)
    MOV R1, [P1]                  ; Load right operand v83
    MUL R0, R1               ; * operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 170              ; Subtract for negative offset (-170)
    MOV [P0], R0                  ; Store result to v84

; Generate random number between 0 and 20 (8-bit)
RNDR P0, 0, 20
    MOV P1, FP                ; Load base pointer
    SUB P1, 172              ; Subtract for negative offset (-172)
    MOV [P1], P0                  ; Store return value to v85
    MOV P0, FP                ; Load base pointer
    SUB P0, 170              ; Subtract for negative offset (-170)
    MOV R0, [P0]                  ; Load left operand v84
    MOV P1, FP                ; Load base pointer
    SUB P1, 172              ; Subtract for negative offset (-172)
    MOV R1, [P1]                  ; Load right operand v85
    ADD R0, R1               ; + operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 174              ; Subtract for negative offset (-174)
    MOV [P0], R0                  ; Store result to v86
    MOV P0, FP                ; Load base pointer
    SUB P0, 174              ; Subtract for negative offset (-174)
    MOV P2, [P0]                  ; Load from v86 (16-bit)
    MOV P1, FP                ; Load base pointer
    SUB P1, 176              ; Subtract for negative offset (-176)
    MOV [P1], P2                  ; Store to v87 (16-bit)
    MOV P0, FP                ; Load base pointer
    SUB P0, 178              ; Subtract for negative offset (-178)
    MOV R0, 32         ; Load constant 32
    MOV [P0], R0                  ; Store to local variable v88
    MOV P0, FP                ; Load base pointer
    SUB P0, 176              ; Subtract for negative offset (-176)
    MOV R0, [P0]                  ; Load left operand v87
    MOV P1, FP                ; Load base pointer
    SUB P1, 178              ; Subtract for negative offset (-178)
    MOV R1, [P1]                  ; Load right operand v88
    MOD R0, R1               ; % operands
    MOV P0, FP                ; Load base pointer
    SUB P0, 180              ; Subtract for negative offset (-180)
    MOV [P0], R0                  ; Store result to v89
    MOV VX, 150             ; Set X coordinate
    MOV VY, 150             ; Set Y coordinate
    MOV P0, FP                ; Load base pointer
    SUB P0, 180              ; Subtract for negative offset (-180)
    MOV R0, [P0]                  ; Load color from v89
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV P0, FP                ; Load base pointer
    SUB P0, 184              ; Subtract for negative offset (-184)
    MOV [P0], R0                  ; Store return value to v90
    HLT                           ; Halt system
    ; Halt processor
    MOV SP, FP                    ; Restore stack pointer
    HLT                           ; Halt system
