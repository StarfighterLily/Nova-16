; Generated by Astrid Pure Stack-Centric Compiler
; Architecture: Nova-16 with pure stack-first approach
; Variables stored on stack, minimal register usage
; Stack Layout: [locals][FP][return_addr][params]

main:
    MOV SP, 0xF000                ; Initialize stack pointer to safe area
    MOV FP, SP                    ; Initialize frame pointer for main
    SUB SP, 20      ; Allocate 20 bytes for locals
    MOV R0, 0         ; Load constant 0
    MOV [FP-4], R0      ; Direct indexed access
    MOV P2, [FP-4]             ; Load from v0 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    CALL draw_layer1          ; Call function
    MOV [FP-8], R0      ; Direct indexed access
    CALL draw_layer2          ; Call function
    MOV [FP-10], R0      ; Direct indexed access
    CALL draw_layer3          ; Call function
    MOV [FP-12], R0      ; Direct indexed access
    MOV P2, [FP-4]             ; Load from v0 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    JMP for_header_0                  ; Unconditional jump
for_header_0:
    MOV R0, 64         ; Load constant 64
    MOV [FP-14], R0      ; Direct indexed access
    MOV P0, [FP-6]          ; Load left operand v1 as 16-bit
    MOV P1, [FP-14]          ; Load right operand v5 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLT cmp_true_1     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_2        ; Skip true case
cmp_true_1:
    MOV R0, 1                     ; Set true result
cmp_end_2:
    MOV [FP-16], R0      ; Direct indexed access
    MOV R0, [FP-16]           ; Load condition v6
    CMP R0, 0                     ; Test condition
    JNZ for_body_1             ; Jump to true branch if non-zero
    JMP for_exit_2            ; Jump to false branch
for_body_1:
    MOV P0, [FP-6]          ; Load left operand v1 as 16-bit
    MOV P1, [FP-14]          ; Load right operand v5 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JZ cmp_true_3     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_4        ; Skip true case
cmp_true_3:
    MOV R0, 1                     ; Set true result
cmp_end_4:
    MOV [FP-18], R0      ; Direct indexed access
    MOV R0, [FP-18]           ; Load condition v7
    CMP R0, 0                     ; Test condition
    JNZ if_then_4             ; Jump to true branch if non-zero
    JMP if_merge_6            ; Jump to false branch
for_increment_3:
    MOV P1, [FP-6]            ; Load current 16-bit value of v1
    ADD P1, 1                     ; Increment 16-bit
    MOV [FP-6], P1      ; Direct indexed access
    JMP for_header_0                  ; Unconditional jump
for_exit_2:
if_then_4:
    MOV P2, [FP-4]             ; Load from v0 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    JMP if_merge_6                  ; Unconditional jump
if_merge_6:
    CALL roll_screen          ; Call function
    MOV [FP-20], R0      ; Direct indexed access
    JMP for_increment_3                  ; Unconditional jump
    ; Halt processor
    MOV SP, FP                    ; Restore stack pointer
    HLT                           ; Halt system

roll_screen:
    PUSH FP                       ; Save caller's frame pointer
    MOV FP, SP                    ; Set new frame pointer
    SUB SP, 20      ; Allocate 20 bytes for locals
    MOV R0, 1         ; Load constant 1
    MOV [FP-20], R0      ; Direct indexed access
    MOV VL, 1         ; Set active layer
    MOV [FP-4], R0      ; Direct indexed access
    MOV R0, 1        ; Set roll amount
    SROLX R0                      ; Roll screen horizontally
    MOV [FP-6], R0      ; Direct indexed access
    MOV R0, 2         ; Load constant 2
    MOV [FP-8], R0      ; Direct indexed access
    MOV VL, 2         ; Set active layer
    MOV [FP-10], R0      ; Direct indexed access
    MOV R0, 2        ; Set roll amount
    SROLX R0                      ; Roll screen horizontally
    MOV [FP-12], R0      ; Direct indexed access
    MOV R0, 3         ; Load constant 3
    MOV [FP-14], R0      ; Direct indexed access
    MOV VL, 3         ; Set active layer
    MOV [FP-16], R0      ; Direct indexed access
    MOV R0, 3        ; Set roll amount
    SROLX R0                      ; Roll screen horizontally
    MOV [FP-18], R0      ; Direct indexed access
    ; Implicit return for void function
    MOV SP, FP                    ; Restore stack pointer
    POP FP                        ; Restore caller's frame pointer
    RET                           ; Return to caller

draw_layer1:
    PUSH FP                       ; Save caller's frame pointer
    MOV FP, SP                    ; Set new frame pointer
    SUB SP, 34      ; Allocate 34 bytes for locals
    MOV R0, 0         ; Load constant 0
    MOV [FP-4], R0      ; Direct indexed access
    MOV P2, [FP-4]             ; Load from v18 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    MOV R0, 1         ; Load constant 1
    MOV [FP-8], R0      ; Direct indexed access
    MOV VL, 1         ; Set active layer
    MOV [FP-10], R0      ; Direct indexed access
    MOV P2, [FP-4]             ; Load from v18 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    JMP for_header_7                  ; Unconditional jump
for_header_7:
    MOV R0, 200         ; Load constant 200
    MOV [FP-12], R0      ; Direct indexed access
    MOV P0, [FP-6]          ; Load left operand v19 as 16-bit
    MOV P1, [FP-12]          ; Load right operand v22 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLE cmp_true_5     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_6        ; Skip true case
cmp_true_5:
    MOV R0, 1                     ; Set true result
cmp_end_6:
    MOV [FP-14], R0      ; Direct indexed access
    MOV R0, [FP-14]           ; Load condition v23
    CMP R0, 0                     ; Test condition
    JNZ for_body_8             ; Jump to true branch if non-zero
    JMP for_exit_9            ; Jump to false branch
for_body_8:
    MOV P1, 256         ; Load 16-bit constant 256
    MOV [FP-16], P1      ; Direct indexed access

; Generate random number between 0 and 256 (16-bit)
RNDR P0, 0, 256
    MOV [FP-18], P0      ; Direct indexed access
    MOV P2, [FP-18]             ; Load from v25 (16-bit)
    MOV [FP-20], P2      ; Direct indexed access

; Generate random number between 0 and 256 (16-bit)
RNDR P0, 0, 256
    MOV [FP-22], P0      ; Direct indexed access
    MOV P2, [FP-22]             ; Load from v27 (16-bit)
    MOV [FP-24], P2      ; Direct indexed access
    MOV R0, 5         ; Load constant 5
    MOV [FP-26], R0      ; Direct indexed access

; Generate random number between 0 and 5 (8-bit)
RNDR P0, 0, 5
    MOV [FP-28], P0      ; Direct indexed access
    MOV P2, [FP-28]             ; Load from v30 (16-bit)
    MOV [FP-30], P2      ; Direct indexed access
    MOV R0, [FP-20]              ; Load X from v26
    MOV VX, R0                    ; Set X coordinate
    MOV R0, [FP-24]              ; Load Y from v28
    MOV VY, R0                    ; Set Y coordinate
    MOV R0, [FP-30]          ; Load color from v31
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV [FP-32], R0      ; Direct indexed access
    JMP for_increment_10                  ; Unconditional jump
for_increment_10:
    MOV R0, [FP-6]           ; Load left operand v19
    MOV R1, [FP-8]          ; Load right operand v20
    ADD R0, R1               ; + operands
    MOV [FP-34], R0      ; Direct indexed access
    MOV P2, [FP-34]             ; Load from v33 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    JMP for_header_7                  ; Unconditional jump
for_exit_9:
    ; Implicit return for void function
    MOV SP, FP                    ; Restore stack pointer
    POP FP                        ; Restore caller's frame pointer
    RET                           ; Return to caller

draw_layer2:
    PUSH FP                       ; Save caller's frame pointer
    MOV FP, SP                    ; Set new frame pointer
    SUB SP, 38      ; Allocate 38 bytes for locals
    MOV R0, 0         ; Load constant 0
    MOV [FP-4], R0      ; Direct indexed access
    MOV P2, [FP-4]             ; Load from v34 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    MOV R0, 2         ; Load constant 2
    MOV [FP-8], R0      ; Direct indexed access
    MOV VL, 2         ; Set active layer
    MOV [FP-10], R0      ; Direct indexed access
    MOV P2, [FP-4]             ; Load from v34 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    JMP for_header_11                  ; Unconditional jump
for_header_11:
    MOV R0, 100         ; Load constant 100
    MOV [FP-12], R0      ; Direct indexed access
    MOV P0, [FP-6]          ; Load left operand v35 as 16-bit
    MOV P1, [FP-12]          ; Load right operand v38 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLE cmp_true_7     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_8        ; Skip true case
cmp_true_7:
    MOV R0, 1                     ; Set true result
cmp_end_8:
    MOV [FP-14], R0      ; Direct indexed access
    MOV R0, [FP-14]           ; Load condition v39
    CMP R0, 0                     ; Test condition
    JNZ for_body_12             ; Jump to true branch if non-zero
    JMP for_exit_13            ; Jump to false branch
for_body_12:
    MOV P1, 256         ; Load 16-bit constant 256
    MOV [FP-16], P1      ; Direct indexed access

; Generate random number between 0 and 256 (16-bit)
RNDR P0, 0, 256
    MOV [FP-18], P0      ; Direct indexed access
    MOV P2, [FP-18]             ; Load from v41 (16-bit)
    MOV [FP-20], P2      ; Direct indexed access

; Generate random number between 0 and 256 (16-bit)
RNDR P0, 0, 256
    MOV [FP-22], P0      ; Direct indexed access
    MOV P2, [FP-22]             ; Load from v43 (16-bit)
    MOV [FP-24], P2      ; Direct indexed access
    MOV R0, 6         ; Load constant 6
    MOV [FP-26], R0      ; Direct indexed access
    MOV R0, 10         ; Load constant 10
    MOV [FP-28], R0      ; Direct indexed access

; Generate random number between 6 and 10 (8-bit)
RNDR P0, 6, 10
    MOV [FP-30], P0      ; Direct indexed access
    MOV P2, [FP-30]             ; Load from v47 (16-bit)
    MOV [FP-32], P2      ; Direct indexed access
    MOV R0, [FP-20]              ; Load X from v42
    MOV VX, R0                    ; Set X coordinate
    MOV R0, [FP-24]              ; Load Y from v44
    MOV VY, R0                    ; Set Y coordinate
    MOV R0, [FP-32]          ; Load color from v48
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV [FP-34], R0      ; Direct indexed access
    JMP for_increment_14                  ; Unconditional jump
for_increment_14:
    MOV R0, 1         ; Load constant 1
    MOV [FP-36], R0      ; Direct indexed access
    MOV R0, [FP-6]           ; Load left operand v35
    MOV R1, [FP-36]          ; Load right operand v50
    ADD R0, R1               ; + operands
    MOV [FP-38], R0      ; Direct indexed access
    MOV P2, [FP-38]             ; Load from v51 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    JMP for_header_11                  ; Unconditional jump
for_exit_13:
    ; Implicit return for void function
    MOV SP, FP                    ; Restore stack pointer
    POP FP                        ; Restore caller's frame pointer
    RET                           ; Return to caller

draw_layer3:
    PUSH FP                       ; Save caller's frame pointer
    MOV FP, SP                    ; Set new frame pointer
    SUB SP, 38      ; Allocate 38 bytes for locals
    MOV R0, 0         ; Load constant 0
    MOV [FP-4], R0      ; Direct indexed access
    MOV P2, [FP-4]             ; Load from v52 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    MOV R0, 3         ; Load constant 3
    MOV [FP-8], R0      ; Direct indexed access
    MOV VL, 3         ; Set active layer
    MOV [FP-10], R0      ; Direct indexed access
    MOV P2, [FP-4]             ; Load from v52 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    JMP for_header_15                  ; Unconditional jump
for_header_15:
    MOV R0, 100         ; Load constant 100
    MOV [FP-12], R0      ; Direct indexed access
    MOV P0, [FP-6]          ; Load left operand v53 as 16-bit
    MOV P1, [FP-12]          ; Load right operand v56 as 16-bit
    CMP P0, P1                    ; Compare 16-bit operands
    JLE cmp_true_9     ; Jump if condition true
    MOV R0, 0                     ; Set false result
    JMP cmp_end_10        ; Skip true case
cmp_true_9:
    MOV R0, 1                     ; Set true result
cmp_end_10:
    MOV [FP-14], R0      ; Direct indexed access
    MOV R0, [FP-14]           ; Load condition v57
    CMP R0, 0                     ; Test condition
    JNZ for_body_16             ; Jump to true branch if non-zero
    JMP for_exit_17            ; Jump to false branch
for_body_16:
    MOV P1, 256         ; Load 16-bit constant 256
    MOV [FP-16], P1      ; Direct indexed access

; Generate random number between 0 and 256 (16-bit)
RNDR P0, 0, 256
    MOV [FP-18], P0      ; Direct indexed access
    MOV P2, [FP-18]             ; Load from v59 (16-bit)
    MOV [FP-20], P2      ; Direct indexed access

; Generate random number between 0 and 256 (16-bit)
RNDR P0, 0, 256
    MOV [FP-22], P0      ; Direct indexed access
    MOV P2, [FP-22]             ; Load from v61 (16-bit)
    MOV [FP-24], P2      ; Direct indexed access
    MOV R0, 11         ; Load constant 11
    MOV [FP-26], R0      ; Direct indexed access
    MOV R0, 15         ; Load constant 15
    MOV [FP-28], R0      ; Direct indexed access

; Generate random number between 11 and 15 (8-bit)
RNDR P0, 11, 15
    MOV [FP-30], P0      ; Direct indexed access
    MOV P2, [FP-30]             ; Load from v65 (16-bit)
    MOV [FP-32], P2      ; Direct indexed access
    MOV R0, [FP-20]              ; Load X from v60
    MOV VX, R0                    ; Set X coordinate
    MOV R0, [FP-24]              ; Load Y from v62
    MOV VY, R0                    ; Set Y coordinate
    MOV R0, [FP-32]          ; Load color from v66
    MOV VM, 0                     ; Set coordinate mode
    SWRITE R0                     ; Write pixel
    MOV [FP-34], R0      ; Direct indexed access
    JMP for_increment_18                  ; Unconditional jump
for_increment_18:
    MOV R0, 1         ; Load constant 1
    MOV [FP-36], R0      ; Direct indexed access
    MOV R0, [FP-6]           ; Load left operand v53
    MOV R1, [FP-36]          ; Load right operand v68
    ADD R0, R1               ; + operands
    MOV [FP-38], R0      ; Direct indexed access
    MOV P2, [FP-38]             ; Load from v69 (16-bit)
    MOV [FP-6], P2      ; Direct indexed access
    JMP for_header_15                  ; Unconditional jump
for_exit_17:
    ; Implicit return for void function
    MOV SP, FP                    ; Restore stack pointer
    POP FP                        ; Restore caller's frame pointer
    RET                           ; Return to caller
